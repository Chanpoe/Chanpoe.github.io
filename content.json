{"meta":{"title":"Chanpoe","subtitle":"Chanpoe`s Blog","description":"本科 | 计算机科学与技术 ","author":"Chanpoe","url":"https://www.chanpoe.top","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2023-02-15T13:34:27.735Z","comments":true,"path":"404.html","permalink":"https://www.chanpoe.top/404.html","excerpt":"","text":""},{"title":"","date":"2023-02-15T14:38:10.730Z","updated":"2023-02-15T13:34:27.806Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://www.chanpoe.top/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2023-02-15T13:34:27.806Z","comments":true,"path":"archives/index.html","permalink":"https://www.chanpoe.top/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-02-15T14:38:15.196Z","updated":"2023-02-15T13:34:27.808Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://www.chanpoe.top/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2023-02-15T13:34:27.806Z","comments":true,"path":"about/index.html","permalink":"https://www.chanpoe.top/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2023-02-15T13:34:27.745Z","comments":true,"path":"List/index.html","permalink":"https://www.chanpoe.top/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2023-02-15T13:34:27.807Z","comments":true,"path":"census/index.html","permalink":"https://www.chanpoe.top/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2023-02-15T13:34:27.808Z","comments":true,"path":"friends/index.html","permalink":"https://www.chanpoe.top/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2023-02-15T13:34:27.808Z","comments":true,"path":"contact/index.html","permalink":"https://www.chanpoe.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2023-02-15T13:34:27.807Z","comments":true,"path":"categories/index.html","permalink":"https://www.chanpoe.top/categories/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2023-02-15T13:34:27.809Z","comments":true,"path":"resource/index.html","permalink":"https://www.chanpoe.top/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2023-02-15T13:34:27.809Z","comments":true,"path":"tags/index.html","permalink":"https://www.chanpoe.top/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-02-15T13:34:27.740Z","updated":"2023-02-15T13:34:27.740Z","comments":true,"path":"List/galleries/index.html","permalink":"https://www.chanpoe.top/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-02-15T13:34:27.746Z","comments":true,"path":"List/tools/index.html","permalink":"https://www.chanpoe.top/List/tools/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2023-02-15T13:34:27.745Z","comments":true,"path":"List/movies/index.html","permalink":"https://www.chanpoe.top/List/movies/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2023-02-15T13:34:27.740Z","updated":"2023-02-15T13:34:27.740Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2023-02-15T13:34:27.741Z","updated":"2023-02-15T13:34:27.741Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2023-02-15T13:34:27.742Z","updated":"2023-02-15T13:34:27.742Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-02-15T13:34:27.746Z","comments":true,"path":"List/music/index.html","permalink":"https://www.chanpoe.top/List/music/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2023-02-15T13:34:27.741Z","updated":"2023-02-15T13:34:27.741Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2023-02-15T13:34:27.741Z","updated":"2023-02-15T13:34:27.741Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2023-02-15T13:34:27.742Z","updated":"2023-02-15T13:34:27.742Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2023-02-15T13:34:27.743Z","updated":"2023-02-15T13:34:27.743Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2023-02-15T13:34:27.743Z","updated":"2023-02-15T13:34:27.743Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2023-02-15T13:34:27.744Z","updated":"2023-02-15T13:34:27.744Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2023-02-15T13:34:27.743Z","updated":"2023-02-15T13:34:27.743Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2023-02-15T13:34:27.744Z","updated":"2023-02-15T13:34:27.744Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2023-02-15T13:34:27.745Z","updated":"2023-02-15T13:34:27.745Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://www.chanpoe.top/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"Anaconda的使用","slug":"Anaconda的使用","date":"2022-11-26T04:06:01.000Z","updated":"2023-02-15T14:44:54.963Z","comments":true,"path":"posts/ea2dc9b0.html","link":"","permalink":"https://www.chanpoe.top/posts/ea2dc9b0.html","excerpt":"","text":"前言：​ 最近在学习机器学习相关的内容，主要是安装GPU版本的Pytorch，总是失败，在网上检索查询发现是pip和Anaconda的环境竟然是天差地别。Anaconda是一个包管理器，可以理解为一个工具，它自带Python（可随意选择版本）解释器以及一些数据分析与挖掘需要的模块而无需用户手动添加的一些常用模块。早期学习Python并没有觉得手动安装包或者模块有多难，后来接触项目的时候才发现了Anaconda的最核心功能。 ​ Anaconda的核心功能在于环境管理，它可以创建虚拟环境，虚拟环境可以拥有自己的Python解释器和一些其他的包的模块，这对我们在实验不同项目环境时候切换自己的环境。Anaconda的虚拟环境保存在安装路径的envs文件夹下，相关的Python解释器和安装的模块都在这个路径下。 一、检查版本和环境： 打开Anaconda Prompt 查看安装的版本： conda --version 查看已经安装的环境： conda env list 二、创建环境： 表示创建一个名字为test_env的环境：（这里环境用的python版本是 3.9版本的） conda create -n test_env python=3.9 创建成功后可以输入conda env list查看是否创建成功 进入环境： Windows: activate test_env Linux下：conda activate test_env 进入之后就可以安装需要的包了 pip install xxxxx 三、删除环境： 删除环境指令： conda remove -n test_env --all 四、复制环境： 复制环境指令： conda create --name new_env_name --clone copied_env_name 参考文章：https://blog.csdn.net/m0_55674689/article/details/125591647 https://blog.csdn.net/weixin_43216928/article/details/117079124","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.chanpoe.top/tags/Python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://www.chanpoe.top/tags/Anaconda/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.chanpoe.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"原神获取ck和sk","slug":"原神获取ck和sk","date":"2022-09-26T15:57:47.000Z","updated":"2023-02-15T14:44:54.978Z","comments":true,"path":"posts/19850a30.html","link":"","permalink":"https://www.chanpoe.top/posts/19850a30.html","excerpt":"","text":"教程 如何获取Cookies？（2022.12.29更新） var cookie=document.cookie;var Str_Num = cookie.indexOf('_MHYUUID=');cookie ='添加 '+cookie.substring(Str_Num);var ask=confirm('Cookie:'+cookie+'\\n\\n按确认，然后粘贴发送给机器人');if(ask==true){copy(cookie);msg=cookie}else{msg='Cancel'} 1.复制上面全部代码，然后用Chrome浏览器的无痕模式打开https://user.mihoyo.com/#/login2.在页面上右键检查或者Ctrl+Shift+i3.选择控制台（Console），粘贴，回车，在弹出的窗口点确认（点完自动复制）4.然后在和机器人的私聊窗口，粘贴发送即可 如何获取Stoken？ var cookie = document.cookie; var ask = confirm('Cookie:' + cookie + '\\n\\n按确认，然后粘贴发送给机器人'); if (ask == true) { copy(\"添加 stoken\" + cookie); msg = cookie } else { msg = 'Cancel' } 1.复制上面全部代码（和第一个Cookies代码不一样，记得重新复制一次），然后用Chrome浏览器的无痕模式打开http://user.mihoyo.com/2.在页面上右键检查或者Ctrl+Shift+i3.选择控制台（Console），粘贴，回车，在弹出的窗口点确认（点完自动复制）4.然后在和机器人的私聊窗口，粘贴发送即可 警告：Cookies、Stoken属于个人隐私，其效用相当于账号密码，请勿随意公开！ PS：向机器人发送绑定信息，可以查看绑定状态。","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"https://www.chanpoe.top/tags/%E8%AF%B4%E6%98%8E/"}]},{"title":"MySQL手册","slug":"MySQL手册","date":"2022-09-25T02:55:35.000Z","updated":"2023-02-15T14:44:54.969Z","comments":true,"path":"posts/4db2237b.html","link":"","permalink":"https://www.chanpoe.top/posts/4db2237b.html","excerpt":"","text":"MySQL修改密码： 使用mysqladmin修改密码 使用 mysqladmin 命令修改 MySQL 的 root 用户密码格式为 mysqladmin -u用户名 -p旧密码 password 新密码 未完待续","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.chanpoe.top/tags/MySQL/"}]},{"title":"xpath笔记","slug":"xpath笔记","date":"2022-09-07T02:35:34.000Z","updated":"2023-02-15T14:44:54.976Z","comments":true,"path":"posts/d2d40360.html","link":"","permalink":"https://www.chanpoe.top/posts/d2d40360.html","excerpt":"","text":"xpath1、xpath安装与使用安装 安装lxml库 pip install lxml -i pip源 常用pip源：清华大学 ：https://pypi.tuna.tsinghua.edu.cn/simple/阿里云：http://mirrors.aliyun.com/pypi/simple/中国科学技术大学 ：http://pypi.mirrors.ustc.edu.cn/simple/华中科技大学：http://pypi.hustunique.com/豆瓣源：http://pypi.douban.com/simple/腾讯源：http://mirrors.cloud.tencent.com/pypi/simple华为镜像源：https://repo.huaweicloud.com/repository/pypi/simple/ 2、解析流程与使用解析流程 实例化一个etree的对象，把即将被解析的页面源码加载到该对象 调用该对象的xpath方法结合着不同形式的xpath表达进行标签定位和数据提取 使用 导入lxml.etree from lxml import etree etree.parse() 解析本地html文件 html_tree = etree.parse(‘XX.html’) etree.HTML()(建议) 解析网络的html字符串 html_tree = etree.HTML(html字符串) html_tree.xpath() 使用xpath路径查询信息，返回一个列表 注意：如果lxml解析本地HTML文件报错可以安装如下添加参数 parser = etree.HTMLParser(encoding=\"utf-8\") selector = etree.parse('./lol_1.html',parser=parser) result=etree.tostring(selector) 3、xpath语法XPath 是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过元素和属性进行导航。 路径表达式 表达式 描述 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 ./ 当前节点再次进行xpath @ 选取属性。 实例 在下面的表格中，我们已列出了一些路径表达式以及表达式的结果： 路径表达式 结果 /html 选取根元素。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ //li 选取所有li 子元素，而不管它们在文档中的位置。 //ul//li 选择属于 ul元素的后代的所有 li元素，而不管它们位于 ul之下的什么位置。 节点对象.xpath(‘./div’) 选择当前节点对象里面的第一个div节点 //@href 选取名为 href 的所有属性。 谓语（Predicates） 谓语用来查找某个特定的节点或者包含某个指定的值的节点。 谓语被嵌在方括号中。 实例 在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果： 路径表达式 结果 /ul/li[1] 选取属于 ul子元素的第一个 li元素。 /ul/li[last()] 选取属于 ul子元素的最后一个 li元素。 /ul/li[last()-1] 选取属于 ul子元素的倒数第二个 li元素。 //ul/li[position()&lt;3] 选取最前面的两个属于 ul元素的子元素的 li元素。 //a[@title] 选取所有拥有名为 title的属性的 a元素。 //a[@title=’xx’] 选取所有 a元素，且这些元素拥有值为 xx的 title属性。 //a[@title&gt;10] &gt; &lt; &gt;= &lt;= != 选取 a元素的所有 title元素，且其中的 title元素的值须大于 10。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 选取未知节点 XPath 通配符可用来选取未知的 XML 元素。 通配符 描述 * 匹配任何元素节点。 一般用于浏览器copy xpath会出现 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 实例 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果： 路径表达式 结果 /ul/* 选取 ul元素的所有子元素。 //* 选取文档中的所有元素。 //title[@*] 选取所有带有属性的 title 元素。 //node() 获取所有节点 选取若干路径 通过在路径表达式中使用“|”运算符，您可以选取若干个路径。 实例 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果： 路径表达式 结果 //book/title | //book/price 选取 book 元素的所有 title 和 price 元素。 //title | //price 选取文档中的所有 title 和 price 元素。 /bookstore/book/title | //price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 逻辑运算 查找所有id属性等于head并且class属性等于s_down的div标签 //div[@id=\"head\" and @class=\"s_down\"] 选取文档中的所有 title 和 price 元素。 //title | //price 注意: “|”两边必须是完整的xpath路径 属性查询 查找所有包含id属性的div节点 //div[@id] 查找所有id属性等于maincontent的div标签 //div[@id=\"maincontent\"] 查找所有的class属性 //@class //@attrName //li[@name=\"xx\"]//text() # 获取li标签name为xx的里面的文本内容 获取第几个标签 索引从1开始 tree.xpath('//li[1]/a/text()') # 获取第一个 tree.xpath('//li[last()]/a/text()') # 获取最后一个 tree.xpath('//li[last()-1]/a/text()') # 获取倒数第二个 模糊查询 查询所有id属性中包含he的div标签 //div[contains(@id, \"he\")] 查询所有id属性中包以he开头的div标签 //div[starts-with(@id, \"he\")] 内容查询 查找所有div标签下的直接子节点h1的内容 //div/h1/text() 属性值获取 //div/a/@href 获取a里面的href属性值 获取所有 //* #获取所有 //*[@class=\"xx\"] #获取所有class为xx的标签 获取节点内容转换成字符串 c = tree.xpath('//li/a')[0] result=etree.tostring(c, encoding='utf-8') print(result.decode('UTF-8'))","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"xpath","slug":"xpath","permalink":"https://www.chanpoe.top/tags/xpath/"}]},{"title":"Bs4笔记","slug":"Bs4笔记","date":"2022-08-29T08:41:17.000Z","updated":"2023-02-15T14:44:54.965Z","comments":true,"path":"posts/b83ea4b0.html","link":"","permalink":"https://www.chanpoe.top/posts/b83ea4b0.html","excerpt":"","text":"beautifulsoup一、beautifulsoup的简单使用简单来说，Beautiful Soup是python的一个库，最主要的功能是从网页抓取数据。官方解释如下： Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 1、安装pip install beautifulsoup4 1.1解析器Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快，推荐安装。 pip install lxml 1.2 解析器对比 官网文档 2、快速开始下面的一段HTML代码将作为例子被多次用到.这是 爱丽丝梦游仙境的 的一段内容(以后内容中简称为 爱丽丝 的文档): html_doc = \"\"\" &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;, &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; \"\"\" 使用BeautifulSoup解析这段代码,能够得到一个 BeautifulSoup 的对象,并能按照标准的缩进格式的结构输出: from bs4 import BeautifulSoup soup = BeautifulSoup(html_doc, 'lxml') # html进行美化 print(soup.prettify()) 匹配代码 &lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"&gt; &lt;b&gt; The Dormouse's story &lt;/b&gt; &lt;/p&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; Elsie &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 几个简单的浏览结构化数据的方法: soup.title # 获取标签title # &lt;title&gt;The Dormouse's story&lt;/title&gt; soup.title.name # 获取标签名称 # 'title' soup.title.string # 获取标签title内的内容 # 'The Dormouse's story' soup.title.parent # 获取父级标签 soup.title.parent.name # 获取父级标签名称 # 'head' soup.p # &lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; soup.p['class'] # 获取p的class属性值 # 'title' soup.a # &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt; soup.find_all('a') # [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] soup.find(id=\"link3\") # 获取id为link3的标签 # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; 从文档中找到所有&lt;a&gt;标签的链接: for link in soup.find_all('a'): print(link.get('href')) # http://example.com/elsie # http://example.com/lacie # http://example.com/tillie 从文档中获取所有文字内容: print(soup.get_text()) 3、如何使用将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄. from bs4 import BeautifulSoup soup = BeautifulSoup(open(\"index.html\")) soup = BeautifulSoup(\"&lt;html&gt;data&lt;/html&gt;\", 'lxml') 然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档。 二、beautifulsoup的遍历文档树还拿”爱丽丝梦游仙境”的文档来做例子: html_doc = \"\"\" &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;, &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt; \"\"\" from bs4 import BeautifulSoup # lxml和html.parser解析的有时候会根据html是否完整而有解析不同的问题，需要注意 soup = BeautifulSoup(html_doc, 'html.parser') 通过这段例子来演示怎样从文档的一段内容找到另一段内容 1、子节点一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性. 注意: Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点。 1.1 .contentstag的 .contents 属性可以将tag的子节点以列表的方式输出: head_tag = soup.head head_tag # &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; head_tag.contents [&lt;title&gt;The Dormouse's story&lt;/title&gt;] title_tag = head_tag.contents[0] title_tag # &lt;title&gt;The Dormouse's story&lt;/title&gt; title_tag.contents # [u'The Dormouse's story'] 字符串没有 .contents 属性,因为字符串没有子节点: text = title_tag.contents[0] text.contents # AttributeError: 'NavigableString' object has no attribute 'contents' 2、 节点内容2.1 .string如果tag只有一个 NavigableString 类型子节点,那么这个tag可以使用 .string 得到子节点。如果一个tag仅有一个子节点,那么这个tag也可以使用 .string 方法,输出结果与当前唯一子节点的 .string 结果相同。 通俗点说就是：如果一个标签里面没有标签了，那么 .string 就会返回标签里面的内容。如果标签里面只有唯一的一个标签了，那么 .string 也会返回最里面的内容。例如： print (soup.head.string) #The Dormouse's story # &lt;title&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/title&gt; print (soup.title.string) #The Dormouse's story 如果tag包含了多个子节点,tag就无法确定，string 方法应该调用哪个子节点的内容, .string 的输出结果是 None print (soup.html.string) #None 2.2 .text如果tag包含了多个子节点, text则会返回内部所有文本内容 print (soup.html.text) 注意： strings和text都可以返回所有文本内容 区别：text返回内容为字符串类型 strings为生成器generator 3、 多个内容.strings .stripped_strings 属性 3.1**.strings**获取多个内容，不过需要遍历获取，比如下面的例子： for string in soup.strings: print(repr(string)) ''' '\\n' \"The Dormouse's story\" '\\n' '\\n' \"The Dormouse's story\" '\\n' 'Once upon a time there were three little sisters; and their names were\\n' 'Elsie' ',\\n' 'Lacie' ' and\\n' 'Tillie' ';\\nand they lived at the bottom of a well.' '\\n' '...' '\\n' ''' 3.2 .stripped_strings输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容 for string in soup.stripped_strings: print(repr(string)) ''' \"The Dormouse's story\" \"The Dormouse's story\" 'Once upon a time there were three little sisters; and their names were' 'Elsie' ',' 'Lacie' 'and' 'Tillie' ';\\nand they lived at the bottom of a well.' '...' ''' 4、 父节点继续分析文档树,每个tag或字符串都有父节点:被包含在某个tag中 4.1 .parent通过 .parent 属性来获取某个元素的父节点.在例子“爱丽丝”的文档中,&lt;head&gt;标签是&lt;title&gt;标签的父节点: title_tag = soup.title title_tag # &lt;title&gt;The Dormouse's story&lt;/title&gt; title_tag.parent # &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; 文档的顶层节点比如&lt;html&gt;的父节点是 BeautifulSoup 对象: html_tag = soup.html type(html_tag.parent) # &lt;class 'bs4.BeautifulSoup'&gt; 三、beautifulsoup的搜索文档树1、find_allfind_all( name , attrs , recursive , string , **kwargs ) find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件: soup.find_all(\"title\") # [&lt;title&gt;The Dormouse's story&lt;/title&gt;] soup.find_all(\"p\", \"title\") # [&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;] soup.find_all(\"a\") # [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] soup.find_all(id=\"link2\") # [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;] import re # 模糊查询 包含sisters的就可以 soup.find(string=re.compile(\"sisters\")) # 'Once upon a time there were three little sisters; and their names were\\n' 有几个方法很相似,还有几个方法是新的,参数中的 string 和 id 是什么含义? 为什么 find_all(\"p\", \"title\") 返回的是CSS Class为”title”的&lt;p&gt;标签? 我们来仔细看一下 find_all() 的参数. 1.1 name 参数name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉. 简单的用法如下: soup.find_all(\"title\") # [&lt;title&gt;The Dormouse's story&lt;/title&gt;] 搜索 name 参数的值可以使任一类型的 过滤器 ,字符串,正则表达式,列表,方法或是 True . &lt;1&gt; 传字符串 最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的标签 soup.find_all('b') # [&lt;b&gt;The Dormouse's story&lt;/b&gt;] &lt;2&gt; 传正则表达式 如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容.下面例子中找出所有以b开头的标签,这表示&lt;body&gt;和&lt;b&gt;标签都应该被找到 import re for tag in soup.find_all(re.compile(\"^b\")): print(tag.name) # body # b &lt;3&gt; 传列表 如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签 soup.find_all([\"a\", \"b\"]) # [&lt;b&gt;The Dormouse's story&lt;/b&gt;, # &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] 1.2 keyword 参数如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性. soup.find_all(id='link2') # [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;] import re # 超链接包含elsie标签 print(soup.find_all(href=re.compile(\"elsie\"))) # [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;] # 以The作为开头的字符串 print(soup.find_all(text=re.compile(\"^The\"))) # [\"The Dormouse's story\", \"The Dormouse's story\"] # class选择器包含st的节点 print(soup.find_all(class_=re.compile(\"st\"))) 搜索指定名字的属性时可以使用的参数值包括 字符串 , 正则表达式 , 列表, True . 下面的例子在文档树中查找所有包含 id 属性的tag,无论 id 的值是什么: soup.find_all(id=True) # [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] 使用多个指定名字的参数可以同时过滤tag的多个属性: soup.find_all(href=re.compile(\"elsie\"), id='link1') # [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;three&lt;/a&gt;] 在这里我们想用 class 过滤，不过 class 是 python 的关键词，这怎么办？加个下划线就可以 print(soup.find_all(\"a\", class_=\"sister\")) ''' [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;, &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; ] ''' 通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag: data_soup.find_all(attrs={\"data-foo\": \"value\"}) # [&lt;div data-foo=\"value\"&gt;foo!&lt;/div&gt;] 注意：如何查看条件id和class同时存在时的写法 print(soup.find_all('b', class_=\"story\", id=\"x\")) print(soup.find_all('b', attrs={\"class\":\"story\", \"id\":\"x\"})) 1.3 text 参数通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True import re print(soup.find_all(text=\"Elsie\")) # ['Elsie'] print(soup.find_all(text=[\"Tillie\", \"Elsie\", \"Lacie\"])) # ['Elsie', 'Lacie', 'Tillie'] # 只要包含Dormouse就可以 print(soup.find_all(text=re.compile(\"Dormouse\"))) # [\"The Dormouse's story\", \"The Dormouse's story\"] 1.4 limit 参数find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果. print(soup.find_all(\"a\",limit=2)) print(soup.find_all(\"a\")[0:2]) ''' [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;, &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;] ''' 2、find()find( name , attrs , recursive , string , **kwargs ) find_all() 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个结果.比如文档中只有一个&lt;body&gt;标签,那么使用 find_all() 方法来查找&lt;body&gt;标签就不太合适, 使用 find_all 方法并设置 limit=1 参数不如直接使用 find() 方法.下面两行代码是等价的: soup.find_all('title', limit=1) # [&lt;title&gt;The Dormouse's story&lt;/title&gt;] soup.find('title') # &lt;title&gt;The Dormouse's story&lt;/title&gt; 唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果. find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 None . print(soup.find(\"nosuchtag\")) # None soup.head.title 是 tag的名字 方法的简写.这个简写的原理就是多次调用当前tag的 find() 方法: soup.head.title # &lt;title&gt;The Dormouse's story&lt;/title&gt; soup.find(\"head\").find(\"title\") # &lt;title&gt;The Dormouse's story&lt;/title&gt; 四、beautifulsoup的css选择器我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加 #，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 soup.select()，返回类型是 list 1、通过标签名查找print(soup.select(\"title\")) #[&lt;title&gt;The Dormouse's story&lt;/title&gt;] print(soup.select(\"b\")) #[&lt;b&gt;The Dormouse's story&lt;/b&gt;] 2、通过类名查找print(soup.select(\".sister\")) ''' [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;, &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;, &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] ''' 3、id名查找print(soup.select(\"#link1\")) # [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;] 4、组合查找组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开 print(soup.select(\"p #link2\")) #[&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;] 直接子标签查找 print(soup.select(\"p &gt; #link2\")) # [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;] 查找既有class也有id选择器的标签 a_string = soup.select(\".story#test\") 查找有多个class选择器的标签 a_string = soup.select(\".story.test\") 查找有多个class选择器和一个id选择器的标签 a_string = soup.select(\".story.test#book\") 5、属性查找查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。 print(soup.select(\"a[href='http://example.com/tillie']\")) #[&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容： for title in soup.select('a'): print (title.get_text()) ''' Elsie Lacie Tillie '''","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Beautifulsou4","slug":"Beautifulsou4","permalink":"https://www.chanpoe.top/tags/Beautifulsou4/"},{"name":"Python","slug":"Python","permalink":"https://www.chanpoe.top/tags/Python/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2022-08-25T09:50:30.000Z","updated":"2023-02-15T14:44:54.983Z","comments":true,"path":"posts/2f57a694.html","link":"","permalink":"https://www.chanpoe.top/posts/2f57a694.html","excerpt":"","text":"一、正则基础1、为什么使用正则 需求 判断一个字符串是否是手机号 解决 编写一个函数，给函数一个字符串，如果是手机号则返回True，否则返回False 代码 def isPhone(phone): # 长度为11 # 全部都是数字字符 # 以1开头 pass if isPhone(\"13812345678\"): print(\"是手机号\") else: print(\"不是手机号\") 注意 如果使用正则会让这个问题变得简单 2、正则与re模块简介概述： 正则表达式，又称规则表达式 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern） 正则匹配是一个 模糊的匹配(不是精确匹配) **re：**python自1.5版本开始增加了re模块，该模块提供了perl风格的正则表达式模式，re模块是python语言拥有了所有正则表达式的功能 如下四个方法经常使用 match() search() findall() finditer() 二、正则表达式1、匹配单个字符与数字 匹配 说明 . 匹配除换行符以外的任意字符，当flags被设置为re.S时，可以匹配包含换行符以内的所有字符 [] 里面是字符集合，匹配[]里任意一个字符 [0123456789] 匹配任意一个数字字符 [0-9] 匹配任意一个数字字符 [a-z] 匹配任意一个小写英文字母字符 [A-Z] 匹配任意一个大写英文字母字符 [A-Za-z] 匹配任意一个英文字母字符 [A-Za-z0-9] 匹配任意一个数字或英文字母字符 [^lucky] []里的^称为脱字符，表示非，匹配不在[]内的任意一个字符 ^[lucky] 以[]中内的某一个字符作为开头 \\d 匹配任意一个数字字符，相当于[0-9] \\D 匹配任意一个非数字字符，相当于[^0-9] \\w 匹配字母、下划线、数字中的任意一个字符，相当于[0-9A-Za-z_] \\W 匹配非字母、下划线、数字中的任意一个字符，相当于[^0-9A-Za-z_] \\s 匹配空白符(空格、换页、换行、回车、制表)，相当于[ \\f\\n\\r\\t] \\S 匹配非空白符(空格、换页、换行、回车、制表)，相当于[^ \\f\\n\\r\\t] 2、匹配锚字符锚字符:用来判定是否按照规定开始或者结尾 匹配 说明 ^ 行首匹配，和[]里的^不是一个意思 $ 行尾匹配 3、限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 匹配 说明 (xyz) 匹配括号内的xyz，作为一个整体去匹配 一个单元 子存储 x? 匹配0个或者1个x，非贪婪匹配 x* 匹配0个或任意多个x x+ 匹配至少一个x x{n} 确定匹配n个x，n是非负数 x{n,} 至少匹配n个x x{n,m} 匹配至少n个最多m个x x y 三、re模块中常用函数通用flags（修正符） 值 说明 re.I 是匹配对大小写不敏感 re.S 使.匹配包括换行符在内的所有字符 通用函数 获取匹配结果 使用group()方法 获取到匹配的值 groups() 返回一个包含所有小组字符串的元组(也就是自存储的值)，从 1 到 所含的小组号。 1、match()函数 原型 def match(pattern, string, flags=0) 功能 匹配成功返回 匹配的对象 匹配失败 返回 None 获取匹配结果 使用group()方法 获取到匹配的值 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 注意：从第一位开始匹配 只匹配一次 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 代码 import re res = re.match('\\d{2}','123') print(res.group()) #给当前匹配到的结果起别名 s = '3G4HFD567' x = re.match(\"(?P&lt;value&gt;\\d+)\",s) print(x.group(0)) print(x.group('value')) 2、search()函数 原型 def search(pattern, string, flags=0) 功能 扫描整个字符串string，并返回第一个pattern模式成功的匹配 匹配失败 返回 None 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 注意： 只要字符串包含就可以 只匹配一次 示例 import re res = re.search('[a-z]', '131A3ab889s') print(res) print(res.group() 注意 与search的区别 相同点： 都只匹配一次 不同点： search是在要匹配的字符串中 包含正则表达式的内容就可以 match 必须第一位就开始匹配 否则匹配失败 3、findall()函数（返回列表） 原型 def findall(pattern, string, flags=0) 功能 扫描整个字符串string，并返回所有匹配的pattern模式结果的字符串列表 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 示例 myStr = \"\"\" &lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;A href=\"http://www.taobao.com\"&gt;淘宝&lt;/A&gt; &lt;a href=\"http://www.id97.com\"&gt;电 影网站&lt;/a&gt; &lt;i&gt;我是倾斜1&lt;/i&gt; &lt;i&gt;我是倾斜2&lt;/i&gt; &lt;em&gt;我是倾斜2&lt;/em&gt; \"\"\" # html里是不区分大小写 # （1）给正则里面匹配的 加上圆括号 会将括号里面的内容进行 单独的返回 res = re.findall(\"(&lt;a href=\\\"http://www\\.(.*?)\\.com\\\"&gt;(.*?)&lt;/a&gt;)\",myStr) #[('&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;', 'baidu', '百度')] # 括号的区别 res = re.findall(\"&lt;a href=\\\"http://www\\..*?\\.com\\\"&gt;.*?&lt;/a&gt;\",myStr) #['&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;'] #(2) 不区分大小写的匹配 res = re.findall(\"&lt;a href=\\\"http://www\\..*?\\.com\\\"&gt;.*?&lt;/a&gt;\",myStr,re.I) #['&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;', '&lt;A href=\"http://www.taobao.com\"&gt;淘宝&lt;/A&gt;'] res = re.findall(\"&lt;[aA] href=\\\"http://www\\..*?\\.com\\\"&gt;.*?&lt;/[aA]&gt;\",myStr) #['&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;'] # (3) 使.支持换行匹配 res = re.findall(\"&lt;a href=\"http://www..?.com\"&gt;.?&lt;/a&gt;\",myStr,re.S) # # (4) 支持换行 支持不区分大小写匹配 res = re.findall(\"&lt;a href=\"http://www..?.com\"&gt;.?&lt;/a&gt;\",myStr,re.S|re.I) # print(res) 4、finditer()函数 原型 def finditer(pattern, string, flags=0) 功能 与findall()类似，返回一个迭代器 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 代码 import re res = re.finditer('\\w', '12hsakda1') print(res) print(next(res)) for i in res: print(i) 5、split()函数 作用：切割字符串 原型： def split(patter, string, maxsplit=0, flags=0) 参数 pattern 正则表达式 string 要拆分的字符串 maxsplit 最大拆分次数 默认拆分全部 flags 修正符 示例 import re myStr = \"asdas\\rd&amp;a\\ts12d\\n*a3sd@a_1sd\" #通过特殊字符 对其进行拆分 成列表 res = re.split(\"[^a-z]\",myStr) res = re.split(\"\\W\",myStr) 6、修正符 作用 对正则进行修正 使用 search/match/findall/finditer 等函数 flags参数的使用 修正符 re.I 不区分大小写匹配 re.S 使.可以匹配换行符 匹配任意字符 使用 re.I print(re.findall('[a-z]','AaBb')) print(re.findall('[a-z]','AaBb', flags=re.I)) re.S print(re.findall('&lt;b&gt;.*?&lt;/b&gt;','&lt;b&gt;b标签&lt;/b&gt;')) print(re.findall('&lt;b&gt;.*?&lt;/b&gt;','&lt;b&gt;b标\\n签&lt;/b&gt;', flags=re.S)) 四、正则高级1、分组&amp;起名称 概念 处理简单的判断是否匹配之外，正则表达式还有提取子串的功能，用()表示的就是要提取的分组 代码 #给当前匹配到的结果起别名 s = '3G4HFD567' re.match(\"(?P&lt;value&gt;\\d+)\",s) print(x.group(0)) print(x.group('value')) 说明 正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来 group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串 2、编译 概念 当在python中使用正则表达式时，re模块会做两件事，一件是编译正则表达式，如果表达式的字符串本身不合法，会报错。另一件是用编译好的正则表达式提取匹配字符串 编译优点 如果一个正则表达式要使用几千遍，每一次都会编译，出于效率的考虑进行正则表达式的编译，就不需要每次都编译了，节省了编译的时间，从而提升效率 compile()函数 原型 def compile(pattern, flags=0) 作用 将pattern模式编译成正则对象 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) flags 标识位，用于控制正则表达式的匹配方式 flags 值 说明 re.I 是匹配对大小写不敏感 re.S 使.匹配包括换行符在内的所有字符 返回值 编译好的正则对象 示例 import re re_phone = re.compile(r\"(0\\d{2,3}-\\d{7,8})\") print(re_phone, type(re_phone)) 编译后其他方法的使用 原型 def match(self, string, pos=0, endpos=-1) def search(self, string, pos=0, endpos=-1) def findall(self, string, pos=0, endpos=-1) def finditer(self, string, pos=0, endpos=-1) 参数 参数 说明 string 待匹配的字符串 pos 从string字符串pos下标开始 endpos 结束下标 示例 s1 = \"lucky's phone is 010-88888888\" s2 = \"kaige's phone is 010-99999999\" ret1 = re_phone.search(s1) print(ret1, ret1.group(1)) ret2 = re_phone.search(s2) print(ret2, ret2.group(1)) 3、贪婪与非贪婪 贪婪模式 贪婪概念：匹配尽可能多的字符 .+ 匹配换行符以外的字符至少一次 .* 匹配换行符以外的字符任意次 实例 res = re.search('&lt;b&gt;.+&lt;/b&gt;', '&lt;b&gt;&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;') res = re.search('&lt;b&gt;.*&lt;/b&gt;', '&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;') 非贪婪模式 非贪婪概念：尽可能少的匹配称为非贪婪匹配，*?、+?即可 .+? 匹配换行符以外的字符至少一次 拒绝贪婪 .*? 匹配换行符以外的字符任意次 拒绝贪婪 实例 res = re.search('&lt;b&gt;.+?&lt;/b&gt;', '&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;') res = re.search('&lt;b&gt;.*?&lt;/b&gt;', '&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;')","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.chanpoe.top/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.chanpoe.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Git的使用","slug":"git的使用","date":"2022-07-28T13:58:06.000Z","updated":"2023-02-15T14:44:54.973Z","comments":true,"path":"posts/3645f6a9.html","link":"","permalink":"https://www.chanpoe.top/posts/3645f6a9.html","excerpt":"","text":"前言：为了对项目进行更好的维护，为了方便进行版本控制，所以Git的学习和使用就变得极为重要，此篇博客记录Git的使用方法和命令，以便之后忘记的时候进行查阅。 一、Git的基本使用及指令： 初始化Git仓库 git init 查看状态 git status 向Git仓库中添加文件（.是所有文件，添加后的文件在Git Bash中查看是绿色的） git add . 提交修改 git commit -m '这里面是修改内容的描述，一定一定一定要好好写，写人话，让自己能看懂' 回滚至之前版本 git log git reset --hard 版本号 回滚至之后版本 git reflog git reset --hard 版本号 git checkout 文件名 git reset --mix 版本号 二、git的工作原理 Git把管理的文件分为了两个区域四个状态。 工作区：当前开发程序所在目录称为工作区，即：工作开发都是在该目录，该区域的文件会有状态的变化且状态由git自动检测，如果程序中文件做任何操作（增、删、改），文件状态均会被检测到，可以使用 git status命令查看。 版本库：工作区检测到有文件发生变化，那么意味着较上一个版本之后对程序进行了修改，修改完成之后，可以当做下一版本进行提交，那么就是执行 git add . 将所有文件提交到暂存区，然后再执行git commit -m '又一个版本'提交到版本库的分支即可，之后可以使用git log命令查看版本记录。 参考文章：https://www.cnblogs.com/wupeiqi/p/7295372.htmlhttps://zhuanlan.zhihu.com/p/465954849","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.chanpoe.top/tags/Git/"}]},{"title":"Django记录","slug":"Django记录","date":"2022-06-20T11:26:03.000Z","updated":"2023-02-15T14:44:54.964Z","comments":true,"path":"posts/a1ca777d.html","link":"","permalink":"https://www.chanpoe.top/posts/a1ca777d.html","excerpt":"","text":"git push的方法： git add . git status //查看git仓库的状态 git commit -m \"此次修改操作的名字\" git push 在acapp中添加 .gitignore文件编辑此文件，可以设置在git push时忽略上传__pycache__ .gitignore文件： */__pycache__","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.chanpoe.top/tags/Python/"},{"name":"django","slug":"django","permalink":"https://www.chanpoe.top/tags/django/"}]},{"title":"Java的this关键字","slug":"Java的this关键字","date":"2022-05-21T08:58:22.000Z","updated":"2023-02-15T14:44:54.968Z","comments":true,"path":"posts/f7f02c1d.html","link":"","permalink":"https://www.chanpoe.top/posts/f7f02c1d.html","excerpt":"","text":"thisthis 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this 的用法在 Java 中大体可以分为3种： 1.普通的直接引用 这种就不用说了，this 相当于是指向当前对象本身。 2.形参（局部变量）与成员变量名字重名，用 this 来区分：（this表示所在方法的调用者的地址值（2022.5.28新理解）） public class GirlFriend { //属性 private int age; //0 public void method() { int age = 10; System.out.println(age); //10 System.out.println(this.age); //0 } } 作用：可以区别成员变量和局部变量。 3.引用构造函数 这个和 super 一起总结，待更新中。。。。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://www.chanpoe.top/tags/java/"}]},{"title":"“浅谈” IPV4 与 IPV6","slug":"浅谈IPV6与IPV4","date":"2022-03-06T00:58:38.000Z","updated":"2023-02-15T14:44:54.984Z","comments":true,"path":"posts/6497bdb4.html","link":"","permalink":"https://www.chanpoe.top/posts/6497bdb4.html","excerpt":"","text":"IPV4 冷知识：我们每个人都需要一个身份号码以识别身份，为了识别网络上的使用者，每台机器其实也有个“身份”——IP，它是唯一的。IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网络层协议。 Internet上的所有计算机，都使用TCP/IP协议作为网络通信的标准。我们熟悉的 IPv4，诞生在1970年代，意思是网际协议第4版(Internet Protocol version 4)，是TCP/IP协议使用的数据报传输机制。 即使IPv4设计得很好，但其缺点也逐渐显露出来，其中最致命的是：数量有限。IPv4地址由点号分隔的四组数字表示。每个数字都是八位二进制数，例如：14.215.177.39。IPv4总共有32位，总共能表示的IP地址大约为43亿。 为什么要用 IPv6？更大的地址空间：IPv6 采用 128 位地址长度，为我们提供了 2^128 个地址，可以说是不受任何限制的提供地址，保守估算 IPv6 实际可分配的地址，整个地球的每平方米面积上仍可分配 1000 多个地址，为全世界的每一粒沙子编上一个 IP 地址真的不是随便说的。 更快的传输速度：IPv6 使用的是固定报头，不像 IPv4 那样携带一堆冗长的数据，简短的报头提升了网络数据转发的效率。并且由于 IPv6 的路由表更小，聚合能力更强，保证了数据转发的路径更短，极大的提高了转发效率，IPv6 也消除了 IPv4 中常见的大部分地址冲突问题，并为设备提供了更多简化的连接和通信。 更安全的传输方式：IPv4 从未被认为是安全的，虽然越来越多的网站正在开启 SSL，但是依旧有大量的网站没有采用 HTTPS，但是 IPv6 从头到尾都是建立在安全的基础上的，在网络层认证与加密数据并对 IP 报文进行校验，为用户提供客户端到服务端的数据安全，保证数据不被劫持。 除了上面这些，相对比 IPv4， IPv6 协议对移动端更加友好，它可以增强移动终端的移动特性、安全特性、路由特性，同时降低网络部署的难度和投资。IPv6 增加了自动配置以及重配置技术，即插即用，对于 IP 地址等信息实现自动增删更新配置，提升 IPv6 的易管理性。 国家也在重视 IPV6 的发展 IPv4 用完了！2019年11月26日下午，负责英国、欧洲、中东和部分中亚地区互联网资源分配的欧洲网络协调中心（RIPE NCC）宣布，全球所有43亿个 IPv4 地址已全部分配完毕，全球IPv4地址耗尽。这意味着没有更多的IPv4地址可以分配给ISP（网络服务提供商）和其他大型网络基础设施提供商。事实上，IPv4 顶级地址（top-level ）在2012年就已耗尽。当时，所有 IPv4 地址空间已分配给全球五大区域互联网注册机构。很快，这五大区域互联网注册机构就用尽了其所拥有的 IPv4 地址。虽然 IPv4 地址耗尽，但世界各国早已开始布局 IPv6。 运营商想了什么新办法维持 IPv4 运行？最常见的是某种 NAT。NAT 是一种共用地址的方式，你可以把它想象成老式电话的公用线路。如果共用的 IP 地址不算太抢手，你也能轻松连上网络。浏览大多数网站是没有问题，但某些地图网站、iTunes 商店等使用大量连接以提升加载速度的网站可能显示不出图片，具体要看多少人在和你共用 IP 地址。邮件是没有问题的，不管是纸邮还是电邮。但是，如果某个网站要封禁违规者，他们往往会封禁其 IP 地址。要是你和 1000 个网民共用一个 IP 地址，但凡有一个人被封禁，你也难逃厄运。运营商不太可能去帮你解决这种问题。 另外，服务器也没法架设在家里了，除非你买一个静态 IP 地址。就算运营商能卖给你，未来几年价格也会持续攀升。一些运营商可能只会给你一个静态 IP 的端口号让你做端口转发，而非独占一个 IP 地址。 P2P 程序，例如语音或视频聊天、电子游戏，甚至那些合法的 BitTorrent 客户端都可能出问题。有些运营商和程序或许能处理得比较好，但大范围的故障在所难免。 现在有些网站还能根据 IPv4 地址自动显示你当地的天气、新闻、影讯，而 NAT 可能也会破坏这一定位机制，你得自己告诉网站你到底在哪儿。 IPV4什么时候结束？大多数运营商不会变更已有的 IPv4 用户所享受的服务，只有当他们选择变更服务时才会被迫与其他人共用一个公网地址。但无论如何，在大多数地方，未来几年内你都有 IPv4 可以用。因此 IPV4/IPV6 双栈将会是一个漫长无限期的过程然后再经过一个漫长几乎无限期的过程后——“无限趋近”IPv6-only.所以说并没有什么强制性的最后期限，但别忘了，IPv4 会渐渐变得难以为继。 参考文章：https://www.miit.gov.cn/jgsj/txs/wjfb/art/2020/art_ed97eb9802da4f168acb823227663f1b.htmlhttps://www.zhihu.com/question/24719173https://baijiahao.baidu.com/s?id=1651519779769763087&amp;wfr=spider&amp;for=pchttp://www.yjcf360.com/jinritoutiao/643466.htm","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://www.chanpoe.top/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"ping不通GitHub的解决方法","slug":"ping不通github的解决方法","date":"2022-03-03T11:44:09.000Z","updated":"2023-02-15T14:44:54.977Z","comments":true,"path":"posts/b6372170.html","link":"","permalink":"https://www.chanpoe.top/posts/b6372170.html","excerpt":"","text":"前言：今天遇到了一个很头疼的问题： 由于Github的CDN （Content Delivery Network，即内容分发网络，基本原理：利用全局负载技术将用户的访问指向当时较近的最佳的CDN节点）被伟大的墙屏蔽，导致我们在国内访问Github会非常地慢，尤其是在clone仓库时，只有几十K的速度，下载半天，还会经常失败，让人头疼。 而Github是程序员的标配，俗话说：“工欲善其事，必先利其器”，所以，本文介绍的是：通过修改hosts文件的方法来绕过国内DNS解析。由于Github只是被DNS污染，而不是像Google那样被IP封锁，所以，我们不需要科学上网，也不需要海外的服务器辅助，这样操作一波后，就可以直接访问Github的CDN节点（主DNS根据一系列策略确定当时最适当的CDN节点，并将解析的结果（IP地址）发给用户，用户向给定的CDN节点请求相应网站的内容 ），从而达到加速的目的。 解决方法：1.首先打开 ipaddress.com 网站，查询以下网址对应地IP： github.com github.global.ssl.fastly.net 记下IP地址 2.打开hosts文件 hosts文件是啥？将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统再会将网址提交DNS域名解析服务器进行IP地址的解析，如果发现是被屏蔽的IP或域名，就会禁止打开此网页！ 目录：C:\\Windows\\System32\\drivers\\etc\\hosts 3.复制查询后地ip，然后在hosts文件中做出相应地修改 4.修改后保存退出，在cmd命令行执行刷新命令: ipconfig/flushdns 会发现已经可以ping通Github了 参考文章:https://blog.csdn.net/qq_42102911/article/details/121485672?spm=1001.2014.3001.5501https://blog.csdn.net/weixin_42232769/article/details/105655388","categories":[{"name":"教程","slug":"教程","permalink":"https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://www.chanpoe.top/tags/GitHub/"}]},{"title":"Hexo关闭渲染","slug":"让Hexo不渲染某些文件","date":"2022-03-03T09:28:43.000Z","updated":"2023-02-15T14:44:54.986Z","comments":true,"path":"posts/73565b1b.html","link":"","permalink":"https://www.chanpoe.top/posts/73565b1b.html","excerpt":"","text":"前言： Hexo在部署的时候会将source文件夹下的所有md文件或者html文件都会被渲染，有时候我们不想这些文件被渲染怎么办？比如很多时候我们想要写一个 README.md、xxxx.html 或者一些自定义的页面。比如百度或者谷歌在验证站长权限的时候，通常都会要求在主目录下添加一个 html 文件。 不渲染 html 文件(不推荐):在不想被渲染的 html 文件最上面添加如下代码: --- layout: false --- 自定义不渲染的文件：skip_render: test/* 单个文件夹下全部文件 skip_render: test/*.md 单个文件夹下指定类型文件 skip_render: test/** 单个文件夹下全部文件以及子目录 多个文件夹以及各种复杂情况： skip_render: README.md - `test1/*.html` - `test2/**` 或者： skip_render: [games/**, depview/**, knowledge/**] 这里的路径匹配可以使用正则表达式。 注意：skip_render参数设置的路径是相对于source目录的路径。例如，需要跳过渲染source/README.md，只需要设置 skip_render:README.md。 在设置了跳过渲染之后，最好使用hexo clean清除以前的编译结果，保证配置生效。 参考文章：https://blog.csdn.net/ganzhilin520/article/details/79057774https://www.cnblogs.com/lfri/p/12219608.html","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.chanpoe.top/tags/hexo/"}]},{"title":"Linux一键搭建Alist","slug":"Alist云盘目录","date":"2022-03-03T07:35:36.000Z","updated":"2023-02-15T14:44:54.962Z","comments":true,"path":"posts/7732d74f.html","link":"","permalink":"https://www.chanpoe.top/posts/7732d74f.html","excerpt":"","text":"Linux一键搭建脚本# 安装 curl -fsSL \"https://nn.ci/alist.sh\" | bash -s install /root # 更新 curl -fsSL \"https://nn.ci/alist.sh\" | bash -s update /root # 卸载 curl -fsSL \"https://nn.ci/alist.sh\" | bash -s uninstall /root 手动搭建参考官方文档：https://alist-doc.nn.ci/docs/install/manual 参考文章：https://alist-doc.nn.ci/docs/install/script","categories":[{"name":"教程","slug":"教程","permalink":"https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Alist","slug":"Alist","permalink":"https://www.chanpoe.top/tags/Alist/"}]},{"title":"Docker容器的迁移","slug":"Docker容器的迁移","date":"2022-02-27T07:26:02.000Z","updated":"2023-02-15T14:44:54.966Z","comments":true,"path":"posts/1b68a79a.html","link":"","permalink":"https://www.chanpoe.top/posts/1b68a79a.html","excerpt":"","text":"前言：今天需要使用docker的迁移功能，于是又是两个小时的爆肝 docker export/import与docker save/load的区别：export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态save/load会保存完整记录，体积更大 如果直接将export&amp;import作用于container，那么打包的东西不会包含存储层的数据，例如，开了一个mysql容器，那么容器中的相关配置信息会保留，但是mysql数据库中存的数据不会被保留。而如果将一个container进行commit后，再使用save&amp;load，可以保留相应的数据。 由于需要保留迁移后的数据，因此使用save&amp;load这种方式。 定制镜像：由于save&amp;load实际操作的是image，所以导出之前，要先使用commit命令把容器中相对于其底层镜像的修改，提交为一层文件系统，与原有的image结合构成一个新的image。新的image中会包含所有修改的内容。（ps：这种制作镜像的方式不被提倡，因为这样做会保留一些元数据信息，导致image过大，如果想用于制作一个简洁的镜像，需使用DockerFile的方式定制镜像，这里不做详述）这样以一个容器salve02为例，将它提交到一个叫做theslave02的镜像上，再打上标签 提交完成后我们可以看到这么一个image： 导出镜像：把镜像导出为一个输出文件： 查看导出的文件： 传输文件：将导出的输出文件通过scp的方式发送到本地的主机上： 导入镜像：在本地主机上，将受到的文件导入为镜像文件: 查看镜像文件： 使用镜像运行容器：使用刚刚导入的镜像，运行为一个容器： docker run -p 19132:19132/udp --name my_docker_server -itd docker_lesson:1.0 # 创建并运行docker_lesson:1.0镜像 使用udp传输 查看容器运行状况： 进入容器： 参考文章：https://blog.csdn.net/weixin_36343850/article/details/80553680x","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.chanpoe.top/tags/Docker/"}]},{"title":"Tmux","slug":"Tmux","date":"2022-01-28T03:58:19.000Z","updated":"2023-02-15T14:44:54.970Z","comments":true,"path":"posts/29b26b27.html","link":"","permalink":"https://www.chanpoe.top/posts/29b26b27.html","excerpt":"","text":"前言：为了让服务器实现窗口挂起，我曾经使用过GNU screen，为的就是保证关闭窗口后，会话不终止。这样做的好处有很多，比如说你在服务器上面搭建一个游戏服，一旦打开了游戏服，你的窗口就必须停留在电脑桌面，如果关闭电脑或是关闭窗口，会话也将随之停止，游戏服就会被强制关闭。还有，如果平常使用服务器窗口进行项目代码的编写时候，突然遇到不可逆的外界因素导致自己的电脑断网或者是突然关机，那么电脑与服务器的连接就会断开，刚才编辑的项目可能造成丢失，这就很必要有一个如上所述的功能来维护我们的操作。所以，学会服务器的终端复用，是我们进修Linux不可或缺的一步。 Tmux简介：1.1 会话与进程 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。 1.2 Tmux 的作用 Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。 （1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 （2） 它可以让新窗口”接入”已经存在的会话。 （3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 （4）它还支持窗口任意的垂直和水平拆分。 类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。 Tmux的安装：2.1 安装 Tmux 一般需要自己安装。 # Ubuntu安装： $ sudo apt-get install tmux # Centos安装： $ sudo yum install tmux 2.2 使用（最强）配置文件点我下载 使用scp将解压后的文件上传到自己的用户目录下。 2.3 启动与退出 安装完成后，键入tmux命令，就进入了 Tmux 窗口。 $ tmux 上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。 tmux教程功能： (1) 分屏。 (2) 允许断开Terminal连接后，继续运行进程。 结构： 一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。 实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ... 操作： (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。 (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。 (3) 按下Ctrl + a后手指松开，然后按\"：将当前pane上下平分成两个pane。 (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。 (5) 鼠标点击可以选pane。 (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。 (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。 (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。 (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。 (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。 (11) tmux a：打开之前挂起的session。 (12) 按下ctrl + a后手指松开，然后按s：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。 (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。 (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。 (16) 鼠标滚轮：翻阅当前pane内的内容。 (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大） (18) tmux中复制/粘贴文本的通用方式： (1) 按下Ctrl + a后松开手指，然后按[ (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板 (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处 参考文章：https://zhuanlan.zhihu.com/p/335818087","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Tmux","slug":"Tmux","permalink":"https://www.chanpoe.top/tags/Tmux/"},{"name":"Linux","slug":"Linux","permalink":"https://www.chanpoe.top/tags/Linux/"}]},{"title":"Centos7 firewalld","slug":"Firewalld","date":"2022-01-21T15:39:32.000Z","updated":"2023-02-15T14:44:54.967Z","comments":true,"path":"posts/25dffcf6.html","link":"","permalink":"https://www.chanpoe.top/posts/25dffcf6.html","excerpt":"","text":"一、firewalld的基本使用启动： systemctl start firewalld查看状态： systemctl status firewalld停止： systemctl disable firewalld禁用： systemctl stop firewalld 二、systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed 三、配置firewalld-cmd查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic 四、如何开启一个端口添加firewall-cmd --zone=public --add-port=80/tcp --permanent （–permanent永久生效，没有此参数重启后失效）重新载入firewall-cmd --reload查看firewall-cmd --zone= public --query-port=80/tcp删除firewall-cmd --zone= public --remove-port=80/tcp --permanent 参考文章：https://www.cnblogs.com/hubing/p/6058932.ht","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Firewalld","slug":"Firewalld","permalink":"https://www.chanpoe.top/tags/Firewalld/"}]},{"title":"Win11安装Android子系统","slug":"Win11安装Android子系统","date":"2022-01-21T07:32:56.000Z","updated":"2023-02-15T14:44:54.973Z","comments":true,"path":"posts/2f9ce033.html","link":"","permalink":"https://www.chanpoe.top/posts/2f9ce033.html","excerpt":"","text":"前提说明：当然你的系统必须是Windows 11 22000正式版系统（最好是专业版）。什么，我Windows 10也想上车？看见右上角那个小叉号了没？ 一、开启处理器虚拟化支持打开电脑💻设置→应用→可选功能→更多Windows功能→勾选hyper-V→勾选powershell2.0→勾选虚拟机平台→确认→重启 注：如果你的系统不是Windows11 专业版，可能会没有hyper-V这个选项，参考：解决方案 （记得重启电脑） 二、安装Window Subsystem for Android应用1.Window Subsystem for Android下载：Windows11 手动安装WSA（Android） 2.从网盘中下载所需要的文件然后管理员身份运行了Powershell执行Add-AppxPackage -Path 下载的文件.Msixbundle即可 Add-AppxPackage -Path (你的下载位置)\\MicrosoftCorporationII.WindowsSubsystemForAndroid_1.7.32815.0_neutral___8wekyb3d8bbwe.Msixbundle 3.打开Window Subsystem for Android应用开发人员模式 通过ADB安装安卓app1.解压ADB（platform-tools-latest-windows.zip),在解压后的目录右键选择”在Windows终端中打开“ 2.ADB链接Android系统： 输入.\\adb connect 127.0.0.1:58526 输入.\\adb install D:**.apk,安装下载的app 在开始菜单可以看到新安装的安卓应用。 参考文章；https://www.coolapk.com/feed/32797179?shareKey=ODRkZTAyMmI0OWQwNjFlYTM2ZTY\\~&amp;shareUid=3164854&amp;shareFrom=com.coolapk.market_11.2.5https://blog.csdn.net/u012514495/article/details/120885242","categories":[{"name":"教程","slug":"教程","permalink":"https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Windows 11","slug":"Windows-11","permalink":"https://www.chanpoe.top/tags/Windows-11/"}]},{"title":"Python format 格式化函数","slug":"格式化函数","date":"2022-01-20T08:40:49.000Z","updated":"2023-02-15T14:44:54.983Z","comments":true,"path":"posts/60cdc116.html","link":"","permalink":"https://www.chanpoe.top/posts/60cdc116.html","excerpt":"","text":"前言：Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 基本语法是通过 {} 和 : 来代替以前的 % 。 format 函数可以接受不限个参数，位置可以不按顺序。 实例： &gt;&gt;&gt;\"{} {}\".format(\"hello\", \"world\") # 不设置指定位置，按默认顺序 'hello world' &gt;&gt;&gt; \"{0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'hello world' &gt;&gt;&gt; \"{1} {0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'world hello world' 也可以设置参数： #!/usr/bin/python # -*- coding: UTF-8 -*- print(\"网站名：{name}, 地址 {url}\".format(name=\"Chanpoe\", url=\"www.chanpoe.top\")) # 通过字典设置参数 site = {\"name\": \"Chanpoe\", \"url\": \"www.chanpoe.top\"} print(\"网站名：{name}, 地址 {url}\".format(**site)) # 通过列表索引设置参数 my_list = ['Chanpoe', 'www.chanpoe.top'] print(\"网站名：{0[0]}, 地址 {0[1]}\".format(my_list)) # \"0\" 是必须的 输出结果是： 网站名：Chanpoe, 地址 www.chanpoe.top 网站名：Chanpoe, 地址 www.chanpoe.top 网站名：Chanpoe, 地址 www.chanpoe.top 也可以向str.format()传入对象：实例： #!/usr/bin/python # -*- coding: UTF-8 -*- class AssignValue(object): def __init__(self, value): self.value = value my_value = AssignValue(6) print('value 为: {0.value}'.format(my_value)) # \"0\" 是可选的 输出结果为： value 为: 6 数字格式化：下表展示了 str.format() 格式化数字的多种方法： &gt;&gt;&gt; print(\"{:.2f}\".format(3.1415926)) 3.14 ^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 + 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 此外我们可以使用大括号 {} 来转义大括号，如下实例： #!/usr/bin/python # -*- coding: UTF-8 -*- print (\"{} 对应的位置是 {{0}}\".format(\"Chanpoe\")) 输出结果为： Chanpoe 对应的位置是 {0} 参考文章：https://www.runoob.com/python/att-string-format.html","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.chanpoe.top/tags/Python/"}]},{"title":"VScode配置C/C++环境","slug":"VScode配置C-C-环境","date":"2022-01-18T05:43:48.000Z","updated":"2023-02-15T14:44:54.972Z","comments":true,"path":"posts/470cf09.html","link":"","permalink":"https://www.chanpoe.top/posts/470cf09.html","excerpt":"","text":"前言：在此之前，我是用的一直都是Visual Studio 2019这款IDE进行代码的编写运行和调试的，但是由于其功能太过冗余，多数功能对于我这种小白来说不太友好，虽然功能强大，但是实用性不高，最主要的是它太占内存了，而且写出的代码也需要放在项目文件里，每一个项目文件就有100多MB，所以确实不太方便。VSCode作为一款微软出的轻量级编辑器，它本身只是一款文本编辑器而已，所有的功能都是以插件扩展的形式所存在，想用什么功能就安装对应的扩展即可，非常方便，同时也支持非常多的主题和图标，外观比较好看，重要的是VSCode支持各大主流操作系统，包括Windows、Linux和Mac OS。所以就选择它作为自己的一款主要的编辑器来使用。下面，就是本次配置环境的方法记录： 一、安装MinGW：(MinGW最好安装在C盘，后面有些问题就不会出现)MinGW下载和安装教程 二、安装VScode：Vscode官网 三、安装各种插件：1.中文语言包：Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code2.编程语言运行扩展：Code Runner3.C/C++：C/C++ 四、配置C/C++环境：1.配置编译器接下来配置编译器路径，按快捷键Ctrl+Shift+P调出命令面板，输入C/C++，选择“Edit Configurations(UI)”进入配置。这里配置两个选项： - 编译器路径：C:\\MinGW\\bin\\g++.exe 配置完成后，此时在侧边栏可以发现多了一个.vscode文件夹，并且里面有一个c_cpp_properties.json文件，说明上述配置成功。内容如下： { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"windowsSdkVersion\": \"10.0.19041.0\", \"compilerPath\": \"C:/MinGW/bin/g++.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\" } ], \"version\": 4 } 2.配置构建任务：接下来，创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。该任务将调用g++编译器基于源代码创建可执行文件。 按快捷键Ctrl+Shift+P调出命令面板，输入tasks，选择“Tasks:Configure Default Build Task”： 此时会出现一个名为tasks.json的配置文件:内容如下： { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"C/C++: g++.exe 生成活动文件\", \"command\": \"C:/MinGW/bin/g++.exe\", \"args\": [ \"-fdiagnostics-color=always\", \"-g\", \"${file}\", \"-o\", \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", \"-fexec-charset=GBK\" //修复中文乱码问题 ], \"options\": { \"cwd\": \"C:/MinGW/bin\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"detail\": \"调试器生成的任务。\" } ], \"version\": \"2.0.0\" } 3.配置调试设置：这里主要是为了在.vscode文件夹中产生一个launch.json文件，用来配置调试的相关信息。新建文件test.cpp输入以下测试代码： #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; system(\"pause\"); return 0; } 使用快捷加 Ctrl + F5， 或者如下图： 会有一个报错，是因为官网版本没有gdb.exe 解决办法：打开cmd运行： mingw-get install gdb 查看launch.json文件：内容如下： { \"version\": \"0.2.0\", // \"cppvsdbg\"不可调试 \"cppdbg\"可调试 \"configurations\": [ //非调试模式 { \"name\": \"非调试模式\", \"type\": \"cppvsdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", \"args\": [ \"/C\", \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", \"&amp;\", \"echo.\", \"&amp;\", \"pause\" ], \"stopAtEntry\": false, \"cwd\": \"${fileDirname}\", \"miDebuggerPath\": \"C:\\\\MinGW\\\\bin\\\\gdb.exe\", \"environment\": [], // \"externalConsole\": true, \"console\": \"externalTerminal\", \"internalConsoleOptions\": \"neverOpen\", \"preLaunchTask\": \"C/C++: g++.exe 生成活动文件\" }, //调试模式 // { // \"name\": \"调试模式\", // \"type\": \"cppdbg\", // \"request\": \"launch\", // \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", // \"args\": [ // \"/C\", // \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", // \"&amp;\", // \"echo.\", // \"&amp;\", // \"pause\" // ], // \"stopAtEntry\": false, // \"cwd\": \"C:/MinGW/bin\", // \"environment\": [], // \"externalConsole\": true, // \"MIMode\": \"gdb\", // \"miDebuggerPath\": \"C:\\\\MinGW\\\\bin\\\\gdb.exe\", // \"setupCommands\": [ // { // \"description\": \"为 gdb 启用整齐打印\", // \"text\": \"-enable-pretty-printing\", // \"ignoreFailures\": true // } // ], // \"preLaunchTask\": \"C/C++: g++.exe 生成活动文件\" // } ] } 注意！！！（需要把\"externalConsole\"的默认值改为 true）加入一句\"console\": \"externalTerminal\",就可以使用外部的控制台了。至此安装已经成功~ 参考文章：VScode配置c++环境（MinGW安装教程）VSCode配置C/C++环境史上最全vscode配置使用教程VS","categories":[{"name":"教程","slug":"教程","permalink":"https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://www.chanpoe.top/tags/VSCode/"}],"author":"Chanpoe"},{"title":"Python 访问字典中元素","slug":"Python访问字典中元素","date":"2022-01-17T03:55:28.000Z","updated":"2023-02-15T14:44:54.970Z","comments":true,"path":"posts/926c01d0.html","link":"","permalink":"https://www.chanpoe.top/posts/926c01d0.html","excerpt":"","text":"一、通过“键值对”(key-value)访问：格式：1.print(dict[key]) dict = {1: 1, 2: 'aa', 'D': 'ee', 'Ty': 45} print(dict['D']) 输出： ee 2.dict.get(key,[default])default为可选项，用于指定当‘键’不存在时 返回一个默认值，如果省略，默认返回None dict = {1: 1, 2: 'aa', 'D': 'ee', 'Ty': 45} print(dict.get(2)) print(dict.get(3)) print(dict.get(4, ['字典中不存在键为4的元素'])) 输出： aa None ['字典中不存在键为4的元素'] 二、遍历字典：1.使用字典对象里的`dict.items()’方法获取字典的各个元素即“键值对”的元组列表： dict = {1: 1, 2: 'aa', 'D': 'ee', 'Ty': 45} for item in dict.items(): print(item) 输出： (1, 1) (2, 'aa') ('D', 'ee') ('Ty', 45) 2.获取到具体的每个键和值： dict = {1: 1, 2: 'aa', 'D': 'ee', 'Ty': 45} for key, value in dict.items(): print(key, value) 输出： 1 1 2 aa D ee Ty 45 3.还可以使用keys()和value()方法获取字典的键和值列表： dict = {1: 1, 2: 'aa', 'D': 'ee', 'Ty': 45} for key in dict.keys(): print(key) for value in dict.values(): print(value) 输出： 1 2 D Ty 1 aa ee 45 参考文章：https://www.cnblogs.com/xioawu-blog/p/11074887.html","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.chanpoe.top/tags/Python/"}]},{"title":"小One抓取位置","slug":"小One抓取位置","date":"2022-01-13T02:13:31.000Z","updated":"2023-02-15T14:44:54.980Z","comments":true,"path":"posts/8900ea1b.html","link":"","permalink":"https://www.chanpoe.top/posts/8900ea1b.html","excerpt":"","text":"一、自己在手机上面打卡一定要给小One位置权限 二、使用电脑登录官网手机号+验证码小One易统计 三、电脑F12，进入开发者工具调试页面找到位置信息，复制发我： 不会使用F12参考：https://blog.csdn.net/weixin_41819731/article/details/80472232","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"https://www.chanpoe.top/tags/%E8%AF%B4%E6%98%8E/"}]},{"title":"拓扑结构","slug":"拓扑结构","date":"2022-01-06T06:20:06.000Z","updated":"2023-02-15T14:44:54.981Z","comments":true,"path":"posts/851dea84.html","link":"","permalink":"https://www.chanpoe.top/posts/851dea84.html","excerpt":"","text":"前言：今天学习神经网络的时候看到了一个拓扑结构的概念，对此比较陌生，所以便对此展开了学习。 一、拓扑结构：首先我们来解释一下拓扑的含义，所谓“拓扑”就是把实体抽象成与其大小、形状无关的“点”，而把连接实体的线路抽象成“线”，进而以图的形式来表示这些点与线之间关系的方法，其目的在于研究这些点、线之间的相连关系。表示点和线之间关系的图被称为拓扑结构图。拓扑结构与几何结构属于两个不同的数学概念。在几何结构中，我们要考察的是点、线之间的位置关系，或者说几何结构强调的是点与线所构成的形状及大小。如梯形、正方形、平行四边形及圆都属于不同的几何结构，但从拓扑结构的角度去看，由于点、线间的连接关系相同，从而具有相同的拓扑结构即环型结构。也就是说，不同的几何结构可能具有相同的拓扑结构。 类似地，在计算机网络中，我们把计算机、终端、通信处理机等设备抽象成点，把连接这些设备的通信线路抽象成线，并将由这些点和线所构成的拓扑称为网络拓扑结构。网络拓扑结构反映出网络的结构关系，它对于网络的性能、可靠性以及建设管理成本等都有着重要的影响，因此网络拓扑结构的设计在整个网络设计中占有十分重要的地位，在网络构建时，网络拓常见的网络拓扑结构。在计算机网络中常见的拓扑结构有总线型、星型、环型、树型和网状型等。 二、不同类型的拓扑结构：1.总线型拓扑： 总线型拓扑中采用单根传输线路作为传输介质，所有站点通过专门的连接器连到这个公共信道上，这个公共的信道称为总线。任何一个站点发送的数据都能通过总线传播，同时能被总线上的所有其他站点接收到。可见，总线型结构的网络是一种广播网络。扑结构往往是首先要考虑的因素之一。在总线结构中，总线有一定的负载能力，因此，总线长度有一定限制，一条总线也只能连接一定数量的结点。总线布局的特点是：结构简单灵活，非常便于扩充;可靠性高，网络响应速度快;设备量少、价格低、安装使用方便;共享资源能力强，极便于广播式工作即一个结点发送所有结点都可接收。总线型拓扑是基本局域网拓扑形式之一。在总线两端连接的器件称为端结器(末端阻抗匹配器、或终止器)。主要与总线进行阻抗匹配，最大限度吸收传送端部的能量，避免信号反射回总线产生不必要的干扰。总线形网络结构是目前使用最广泛的结构，也是最传统的一种主流网络结构，适合于信息管理系统、办公自动化系统领域的应用。 2.星型拓扑：星型拓扑中有一个中心节点，其他各节点通过各自的线路与中心节点相连，形成辐射型结构。各节点间的通信必须通过中心节点的作用，如图A 到B 或A到C 都要经过中心节点D。星型拓扑的网络具有结构简单、易于建网和易于管理等特点。但这种结构要耗费大量的电缆，同时中心节点的故障会直接造成整个网络的瘫痪。星型拓扑也经常应用于局域网中。星型布局是以中央结点为中心与各结点连接而组成的，各结点与中央结点通过点与点方式连接，中央点执行集中式通信控制策略，因此中央结点相当复杂，负担也重。目前流行的PBX就是星型拓扑结构的典型实例，如图所示。以星型拓扑结构组网，其中任何两个站点要进行通信都必须经过中央结点控制。中央结点主要功能有 为需要通信的设备建立物理连接 为两台设备通信过程中维持这一通路 在完成通信或不成功时,拆除通道在文件服务器/工作站(File Server/Workstation )局域网模式中，中心点为文件服务器，存放共享资源。由于这种拓扑结构，中心点与多台工作站相连,为便于集中连线，目前多采用集线器(HUB)。星型拓扑结构特点:网络结构简单,便于管理、集中控制, 组网容易;网络延迟时间短，误码率低，网络共享能力较差，通信线路利用率不高，中央节点负担过重，可同时连双绞线、同轴电缆及光纤等多种媒介。树型拓扑结构可以看作成星型拓扑的一种扩展，也称扩展星型拓扑。 3.环形拓扑： 如图所示，在环型拓扑中，各节点和通信线路连接形成的一个闭合的环。在环路中，数据按照一个方向传输。发送端发出的数据，延环绕行一周后，回到发送端，由发送端将其从环上删除。我们可以看到任何一个节点发出的数据都可以被环上的其他节点接收到。环型拓扑具有结构简单，容易实现，传输时延确定以及路径选择简单等优点，但是，网络中的每一个节点或连接节点的通信线路都有可能成为网络可靠性的瓶颈。当网络中的任何一个节点出现故障都可能会造成网络的瘫痪。另外，在这种拓扑结构中，节点的加入和拆除过程比较复杂。环型拓扑也是局域网中常用的一种拓扑形式。环形网的特点是：信息在网络中沿固定方向流动，两个结点间仅有唯一的通路，大大简化了路径选择的控制;某个结点发生故障时，可以自动旁路，可靠性较高;由于信息是串行穿过多个结点环路接口，当结点过多时，影响传输效率，使网络响应时间变长。但当网络确定时，其延时固定，实时性强;由于环路封闭故扩充不方便。环形网也是微机局域网常用拓扑结构之一，适合信息处理系统和工厂自动化系统。1985年IBM公司推出的令牌环形网(IBM Token Ring)是其典范。在FDDI得以应用推广后，这种结构会进一步得到采用。 4.网状拓扑： 在网状拓扑结构中，节点之间的连接是任意的，每个节点都有多条线路与其他节点相连，这样使得节点之间存在多条路径可选，如图1.7中从A 到C 可以是A-B-C 也可以是A-D-B-C，在传输数据时可以灵活的选用空闲路径或者避开故障线路。可见网状拓扑可以充分、合理的使用网络资源，并且具有可靠性高的优点。我们知道，广域网覆盖面积大，传输距离长，网络的故障会给大量的用户带来严重的危害，因此在广域网中，为了提高网络的可靠性通常采用网状拓扑结构，如图所示为一个简单的广域网示意图。但是我们也应该看到，这个优点是以高投资和高复杂的管理为代价的。将多个子网或多个局域网连接起来构成网状型拓扑结构。在一个子网中，集线器、中继器将多个设备连接起来，而桥接器、路由器及网关则将子网连接起来。根据组网硬件不同，主要有三种网状型拓扑:①网状网：在一个大的区域内，用无线通信连路连接一个大型网络时，网状网是最好的拓扑结构。通过路由器与路由器相连，可让网络选择一条最快的路径传送数据。②主干网：通过桥接器与路由器把不同的子网或LAN 连接起来形成单个总线或环型拓扑结构，这种网通常采用光纤做主干线。③星状相连网：利用一些叫做超级集线器的设备将网络连接起来，由于星型结构的特点，网络中任一处的故障都可容易查找并修复。应该指出,在实际组网中,拓扑结构不一定是单一的,通常是几种结构的混用。比如，将总线型与星型结合起来就形成了总线型/星型拓扑结构，用一条或多条总线把多组设备连接起来，相连的每组设备呈星型分布。采用这种拓扑结构，用户很容易配置和重新配置网络设备。如图所示。 参考文章：https://blog.csdn.net/starshinning975/article/details/53511343","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"拓扑","slug":"拓扑","permalink":"https://www.chanpoe.top/tags/%E6%8B%93%E6%89%91/"}],"author":"Chanpoe"},{"title":"使用华为云搭建图床","slug":"使用华为云搭建图床","date":"2022-01-03T06:40:00.000Z","updated":"2023-02-15T14:44:54.976Z","comments":true,"path":"posts/5b992d75.html","link":"","permalink":"https://www.chanpoe.top/posts/5b992d75.html","excerpt":"","text":"前言：面对各大图床日益降低我们的图片上传的体积，面对图床服务器不稳定的各种问题，搭建一个属于自己的图床是我们的不二选择，今天下午突然发现了各大云（华为云、阿里云、腾讯云等等）都有对象储存服务的售卖，其中，目前发现华为云提供按量收费，价格真的很良心！这样看来，如果平常日用，一个G才需要0.1，哇，果断搞起！附链接：华为云储存收费详情 一、注册华为云账号，登录进入首页控制台： 一定要进入北京四的区域（便宜(可能bushi)） 二、打开对象储存服务OBS： 创建桶： 输入桶的名称 重点：选择公共读 三、获取AK和SK：在总览里面打开获取AK和SK： 获取到一个csv文件，里面有AccessKeyID和AccessKeySecret： 四、在桶里新建储存图片的文件夹： 五、记下桶名称、Endpoint信息： 六、在Github上下载PicGo软件：下载地址：PicGo 七、打开PicGo软件，在插件设置中下载华为云OBS： 八、上传区选择华为云OBS即可上传： 参考文章：https://blog.csdn.net/weixin_44289959/article/details/120631050阿里云oss储存OSS连接(不推荐)","categories":[{"name":"教程","slug":"教程","permalink":"https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://www.chanpoe.top/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"搭建个人博客","slug":"搭建个人博客","date":"2022-01-02T13:48:35.000Z","updated":"2023-02-15T14:44:54.982Z","comments":true,"path":"posts/c442673f.html","link":"","permalink":"https://www.chanpoe.top/posts/c442673f.html","excerpt":"","text":"一、本地搭建博客：(以下代码在CMD上运行)1.在Windows本地下载Node.js：Node.js官网 2.安装cnpm： npm install -g cnpm --registry=https://registry.npm.taobao.org 3.使用cnpm在Windows本地安装hexo博客： cnpm install -g hexo-cli 4.在Windows本地新建blog文件夹：CMD： md blog 5.初始化hexo： hexo init 初始化成功后可以打开 http://localhost:4000 验证效果 6.在package.json文件中添加npm脚本： \"scripts\": { \"deploy\": \"hexo clean &amp;&amp; hexo g -d\", \"start\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\" }, （方便部署到服务器）添加后就可以直接在第四个步骤做完以后上传到服务器了： npm run deploy 二、git环境搭建：1.在官网下载安装git：git官网 2.生成ssh认证： git config --global user.name \"yourname\" git config --global user.email youremail@example.com ssh-keygen -t rsa -C \"youremail@example.com\" git config --global core.autocrlf false // 禁用自动转换，这个不设置后面上传时会出现警告 注：最后获取到的ssh认证在C:Usersyourname.ssh中 3.安装git： git --version // 如无，则安装 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel yum install -y git 4.在服务器新建用户并配置其仓库： useradd git passwd git // 设置密码 su git // 这步很重要，不切换用户后面会很麻烦 cd /home/git/ mkdir -p projects/blog // 项目存在的真实目录 mkdir repos &amp;&amp; cd repos git init --bare blog.git // 创建一个裸露的仓库 cd blog.git/hooks vi post-receive // 创建 hook 钩子函数，输入了内容如下 #!/bin/sh git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f 添加完成后修改权限： chmod +x post-receive exit // 退出到 root 登录 chown -R git:git /home/git/repos/blog.git // 添加权限 5.测试git仓库是否可用，在Windows本地另找文件夹 git clone git@server_ip:/home/git/repos/blog.git 如果可以git下来空的仓库，就说明git仓库搭建成功了： 三、建立本地与服务器的连接：1.在Windows本地建立ssh信任关系：（Windows使用git Bash执行） ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ip ssh git@server_ip // 测试能否登录 2.(可选)为了安全起见，要禁用git用户的shell登录权限，从而使其只能使用git clone、git push等登录： cat /etc/shells // 查看 git-shell 是否在登录方式里面 which git-shell // 查看是否安装 vi /etc/shells 添加上2步显示出来的路劲，通常在 /usr/bin/git-shell 修改/etc/passwd中的权限： // 将原来的 git:x:1000:1000::/home/git:/bin/bash // 修改为 git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell 四、部署到服务器（ngnix的使用）：1.下载并安装nginx： cd /usr/local/src wget http://nginx.org/download/nginx-1.15.2.tar.gz tar xzvf nginx-1.15.2.tar.gz cd nginx-1.15.2 ./configure // 如果后面还想要配置 SSL 协议，就执行后面一句！ ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module yum -y install gcc gcc-c++ autoconf automake make // 安装C++编译环境 make &amp;&amp; make install alias nginx='/usr/local/nginx/sbin/nginx' // 为 nginx 取别名，后面可直接用 如果Nginx不能访问： 1:查看防火状态 systemctl status firewalld service iptables status 2:暂时关闭防火墙 systemctl stop firewalld service iptables stop 3:永久关闭防火墙 systemctl disable firewalld chkconfig iptables off 4:重启防火墙 systemctl enable firewalld service iptables restart 5:永久关闭后重启 //暂时还没有试过 chkconfig iptables on 2.测试是否安装成功： nginx 浏览器直接访问服务器的公网ip如果可以访问，则说明安装成功，继续执行下面的操作。 停止nginx： nginx -s stop // 先停止nginx 3.修改nginx配置文件： cd /usr/local/nginx/conf vi nginx.conf 修改 root 解析路径，如下图 同时将 user 改为 root 如下图，不然nginx无法访问 /home/git/projects/blog 然后更新nginx配置： sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf nginx -s reload 4.配置_config.yml文件里的deploy属性： 5.上传本地博客到服务器： npm run deploy 6.(可选)将http网站设置为https：需要获取SSL证书阿里云官方文档 参考文献：https://blog.csdn.net/qq_35561857/article/details/81590953https://www.jianshu.com/p/ea78bdd0551f/https://blog.csdn.net/afei__/article/details/80717153","categories":[{"name":"教程","slug":"教程","permalink":"https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.chanpoe.top/tags/hexo/"}]}],"categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"教程","slug":"教程","permalink":"https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.chanpoe.top/tags/Python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://www.chanpoe.top/tags/Anaconda/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.chanpoe.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"说明","slug":"说明","permalink":"https://www.chanpoe.top/tags/%E8%AF%B4%E6%98%8E/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.chanpoe.top/tags/MySQL/"},{"name":"xpath","slug":"xpath","permalink":"https://www.chanpoe.top/tags/xpath/"},{"name":"Beautifulsou4","slug":"Beautifulsou4","permalink":"https://www.chanpoe.top/tags/Beautifulsou4/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.chanpoe.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Git","slug":"Git","permalink":"https://www.chanpoe.top/tags/Git/"},{"name":"django","slug":"django","permalink":"https://www.chanpoe.top/tags/django/"},{"name":"java","slug":"java","permalink":"https://www.chanpoe.top/tags/java/"},{"name":"网络","slug":"网络","permalink":"https://www.chanpoe.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"GitHub","slug":"GitHub","permalink":"https://www.chanpoe.top/tags/GitHub/"},{"name":"hexo","slug":"hexo","permalink":"https://www.chanpoe.top/tags/hexo/"},{"name":"Alist","slug":"Alist","permalink":"https://www.chanpoe.top/tags/Alist/"},{"name":"Docker","slug":"Docker","permalink":"https://www.chanpoe.top/tags/Docker/"},{"name":"Tmux","slug":"Tmux","permalink":"https://www.chanpoe.top/tags/Tmux/"},{"name":"Linux","slug":"Linux","permalink":"https://www.chanpoe.top/tags/Linux/"},{"name":"Firewalld","slug":"Firewalld","permalink":"https://www.chanpoe.top/tags/Firewalld/"},{"name":"Windows 11","slug":"Windows-11","permalink":"https://www.chanpoe.top/tags/Windows-11/"},{"name":"VSCode","slug":"VSCode","permalink":"https://www.chanpoe.top/tags/VSCode/"},{"name":"拓扑","slug":"拓扑","permalink":"https://www.chanpoe.top/tags/%E6%8B%93%E6%89%91/"},{"name":"图床","slug":"图床","permalink":"https://www.chanpoe.top/tags/%E5%9B%BE%E5%BA%8A/"}]}