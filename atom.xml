<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chanpoe</title>
  
  <subtitle>Chanpoe`s Blog</subtitle>
  <link href="https://www.chanpoe.top/atom.xml" rel="self"/>
  
  <link href="https://www.chanpoe.top/"/>
  <updated>2025-08-26T18:35:55.970Z</updated>
  <id>https://www.chanpoe.top/</id>
  
  <author>
    <name>Chanpoe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建饥荒联机版服务器</title>
    <link href="https://www.chanpoe.top/posts/150de331.html"/>
    <id>https://www.chanpoe.top/posts/150de331.html</id>
    <published>2025-08-26T18:30:34.000Z</published>
    <updated>2025-08-26T18:35:55.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="饥荒联机版开服教程"><a href="#饥荒联机版开服教程" class="headerlink" title="饥荒联机版开服教程"></a>饥荒联机版开服教程</h3><p>服务器系统：Linux Ubuntu 20.04</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><pre class="line-numbers language-none"><code class="language-none"># 64-bit machine: sudo apt-get install libstdc++6:i386 libgcc1:i386 libcurl4-gnutls-dev:i386# 32-bit machine: sudo apt-get install libstdc++6 libgcc1 libcurl4-gnutls-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建专用用户"><a href="#创建专用用户" class="headerlink" title="创建专用用户"></a>创建专用用户</h3><pre class="line-numbers language-none"><code class="language-none">sudo adduser --disabled-login dstsudo su - dst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="安装-SteamCMD"><a href="#安装-SteamCMD" class="headerlink" title="安装 SteamCMD"></a>安装 SteamCMD</h3><pre class="line-numbers language-none"><code class="language-none">mkdir ~/steamcmd &amp;&amp; cd ~/steamcmdwget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gztar -xvzf steamcmd_linux.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="下载-DST-服务器"><a href="#下载-DST-服务器" class="headerlink" title="下载 DST 服务器"></a>下载 DST 服务器</h3><p>进入 steamcmd 并安装 DST 服务器：</p><pre class="line-numbers language-none"><code class="language-none">~/steamcmd/steamcmd.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 SteamCMD 中依次输入：</p><pre class="line-numbers language-none"><code class="language-none">login anonymousforce_install_dir /home/dst/dontstarvetogether_dedicated_serverapp_update 343050 validatequit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>343050</code> 是 DST Dedicated Server 的 AppID。<br> 安装完成后，DST 服务端文件在 <code>~/dstserver</code> 目录。</p></blockquote><h3 id="下载官方提供的服务器认证token信息"><a href="#下载官方提供的服务器认证token信息" class="headerlink" title="下载官方提供的服务器认证token信息"></a>下载官方提供的服务器认证token信息</h3><p>下载方式如图</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250826194637.png"></p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/image-20250826194724665.png"></p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250826194811.png"></p><p>将下载的压缩包中的<code>MyDediServer</code>解压到服务器的<code>/home/dst/.klei/DoNotStarveTogether</code>目录下</p><hr><h3 id="添加游戏配置-amp-mod"><a href="#添加游戏配置-amp-mod" class="headerlink" title="添加游戏配置&amp;mod"></a>添加游戏配置&amp;mod</h3><h4 id="游戏配置"><a href="#游戏配置" class="headerlink" title="游戏配置"></a>游戏配置</h4><p>本地开服创建配置存档，然后打开本地存档文件，将本地<code>Master</code>、<code>Caves</code>中的<code>leveldataoverride.lua</code>、<code>modoverrides.lua</code>放到服务器<code>/home/dst/.klei/DoNotStarveTogether/MyDediServer</code>同级目录下</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/image-20250827021936495.png"></p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250827022239.png"></p><h4 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h4><p>从本地文件夹找到对应的mod放到<code>/home/dst/dontstarvetogether_dedicated_server/mods</code>下</p><pre class="line-numbers language-none"><code class="language-none"># mod存放的路径，需要点开对应文件夹查看 自己判断一下是不是缺文件了E:\SteamLibrary\steamapps\common\Don't Starve Together\modsE:\SteamLibrary\steamapps\workshop\content\322330<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="开服"><a href="#开服" class="headerlink" title="开服"></a>开服</h3><p>将下面的配置文件写入 <code>~/run_dedicated_servers.sh</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">steamcmd_dir</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/steamcmd"</span><span class="token assign-left variable">install_dir</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/dontstarvetogether_dedicated_server"</span><span class="token assign-left variable">cluster_name</span><span class="token operator">=</span><span class="token string">"MyDediServer"</span><span class="token assign-left variable">dontstarve_dir</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/.klei/DoNotStarveTogether"</span><span class="token keyword">function</span> <span class="token function-name function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token builtin class-name">echo</span> Error: <span class="token string">"<span class="token variable">$@</span>"</span> <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span><span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function-name function">check_for_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>fail <span class="token string">"Missing file: <span class="token variable">$1</span>"</span><span class="token keyword">fi</span><span class="token punctuation">}</span><span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$steamcmd_dir</span>"</span> <span class="token operator">||</span> fail <span class="token string">"Missing <span class="token variable">$steamcmd_dir</span> directory!"</span>check_for_file <span class="token string">"steamcmd.sh"</span>check_for_file <span class="token string">"<span class="token variable">$dontstarve_dir</span>/<span class="token variable">$cluster_name</span>/cluster.ini"</span>check_for_file <span class="token string">"<span class="token variable">$dontstarve_dir</span>/<span class="token variable">$cluster_name</span>/cluster_token.txt"</span>check_for_file <span class="token string">"<span class="token variable">$dontstarve_dir</span>/<span class="token variable">$cluster_name</span>/Master/server.ini"</span>check_for_file <span class="token string">"<span class="token variable">$dontstarve_dir</span>/<span class="token variable">$cluster_name</span>/Caves/server.ini"</span>./steamcmd.sh +force_install_dir <span class="token string">"<span class="token variable">$install_dir</span>"</span> +login anonymous +app_update <span class="token number">343050</span> validate +quitcheck_for_file <span class="token string">"<span class="token variable">$install_dir</span>/bin64"</span><span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$install_dir</span>/bin64"</span> <span class="token operator">||</span> fail<span class="token assign-left variable">run_shared</span><span class="token operator">=</span><span class="token punctuation">(</span>./dontstarve_dedicated_server_nullrenderer_x64<span class="token punctuation">)</span><span class="token assign-left variable">run_shared</span><span class="token operator">+=</span><span class="token punctuation">(</span>-console<span class="token punctuation">)</span><span class="token assign-left variable">run_shared</span><span class="token operator">+=</span><span class="token punctuation">(</span>-cluster <span class="token string">"<span class="token variable">$cluster_name</span>"</span><span class="token punctuation">)</span><span class="token assign-left variable">run_shared</span><span class="token operator">+=</span><span class="token punctuation">(</span>-monitor_parent_process <span class="token variable">$$</span><span class="token punctuation">)</span><span class="token string">"<span class="token variable">${run_shared<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span> <span class="token parameter variable">-shard</span> Caves  <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^/Caves:  /'</span> <span class="token operator">&amp;</span><span class="token string">"<span class="token variable">${run_shared<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span> <span class="token parameter variable">-shard</span> Master <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^/Master: /'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给脚本执行权限：</p><pre class="line-numbers language-none"><code class="language-none">chmod u+x ~/run_dedicated_servers.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动脚本：</p><pre class="line-numbers language-none"><code class="language-none">~/run_dedicated_servers.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://forums.kleientertainment.com/forums/topic/64441-dedicated-server-quick-setup-guide-linux/">https://forums.kleientertainment.com/forums/topic/64441-dedicated-server-quick-setup-guide-linux/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="教程" scheme="https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="饥荒联机版" scheme="https://www.chanpoe.top/tags/%E9%A5%A5%E8%8D%92%E8%81%94%E6%9C%BA%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>AI Agent</title>
    <link href="https://www.chanpoe.top/posts/77426c02.html"/>
    <id>https://www.chanpoe.top/posts/77426c02.html</id>
    <published>2025-08-18T12:03:01.000Z</published>
    <updated>2025-08-18T12:53:57.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚开始接触大语言模型（LLMs）时，我以为关键在于写出完美的提示词。只要给它足够的上下文 —— 然后，砰的一下 —— 它就该能正常工作了，对吧？事实并非如此。</p><p>起初我意识到，自己基本上就是在对着一个高级版自动补全工具堆砌文字。生成的内容看起来很聪明，但模型其实什么都不懂。它不会规划、不会调整，也不会推理。只要措辞表达稍有改动，整个输出就会出问题。</p><p>真正的智慧不只是给出答案，更在于<strong>答案的形成过程</strong>。这个过程至关重要。</p><p>这促使我研究起智能体模式—— 一种能赋予大语言模型更多 “目的性” 的设计技巧。它能让模型进行规划、反思、使用工具，甚至与其他智能体协作。借助这些模式，可以很好的摆脱那些时灵时不灵的提示词，找到了能真正解决问题的方法。</p><p>下面就来具体讲讲这五种对我帮助最大的模式，解释会尽量通俗易懂、便于实践。</p><hr><h3 id="一、反思（Reflection）：Teach-Your-Agent-to-Check-Its-Own-Work"><a href="#一、反思（Reflection）：Teach-Your-Agent-to-Check-Its-Own-Work" class="headerlink" title="一、反思（Reflection）：Teach Your Agent to Check Its Own Work"></a>一、反思（Reflection）：Teach Your Agent to Check Its Own Work</h3><p>你有没有过这样的经历：问了 ChatGPT 一个问题，读完答案后总觉得 “听起来还行…… 但好像哪里不对劲”？</p><p>这时候，<strong>反思（Reflection）</strong>就派上用场了。这是个简单的技巧：让模型在给出最终答案前，先自己检查一遍输出内容。</p><p>基本流程是：</p><ol><li>提出问题。</li><li>让模型给出答案。</li><li>然后再提示它：“这个回答完整吗？有没有遗漏什么？怎样能更好？”</li><li>让它自己修改完善。</li></ol><p>说实话，单这一步就能减少很多粗心的错误 —— 尤其是在代码、总结这类对细节要求高的内容上。可以把这理解为给你的模型加了个暂停键和一面镜子。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250818202013.png"></p><hr><h3 id="二、使用工具（Tool-Use）：Don’t-Expect-the-Model-to-Know-Everything"><a href="#二、使用工具（Tool-Use）：Don’t-Expect-the-Model-to-Know-Everything" class="headerlink" title="二、使用工具（Tool Use）：Don’t Expect the Model to Know Everything"></a>二、使用工具（Tool Use）：Don’t Expect the Model to Know Everything</h3><p>大语言模型（LLM）并不知道你的数据库里有什么，也不知道你的文件内容或今日新闻。不过没关系 —— 因为你可以让它自己去获取这些信息。</p><p><strong>使用工具（Tool Use）</strong>的模式能把模型和现实世界的工具连接起来。这样一来，它就不用凭空编造内容了，而是可以查询向量数据库、在交互式解释器（REPL）中运行代码，或者调用外部 API，乃至你内部的接口。这种设置需要一些 “管道搭建”：函数调用、路由配置，或许还得需要用 LangChain 或 Semantic Kernel 这类工具，但付出是值得的。你的智能体不再靠猜，而是能调取真实数据了。人们总以为大语言模型天生就该很聪明。其实并非如此。但当它们能使用合适的工具时，就会变得聪明得多。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250818202852.png"></p><hr><h3 id="三、推理与行动（React）：Let-the-Model-Think-While-It-Acts"><a href="#三、推理与行动（React）：Let-the-Model-Think-While-It-Acts" class="headerlink" title="三、推理与行动（React）：Let the Model Think While It Acts"></a>三、推理与行动（React）：Let the Model Think While It Acts</h3><p>“反思” 模式很好，“使用工具” 模式也很棒。但如果让你的智能体在思考和行动中形成循环，效果会更好。这就是 “ReAct” 模式的核心：<strong>推理（Reasoning）+ 行动（Acting）</strong>。<a href="https://cursor.com/en">Cursor</a>和<a href="https://www.trae.ai/">Trae</a>这种AI IDE便是很好的实践。模型不会一次性给出所有答案，而是会逐步推理，并在了解更多信息后调整自己的行动。</p><p>要让 ReAct 模式发挥作用，你需要三样东西：</p><ul><li>工具（用于采取行动）</li><li>记忆（用于保留上下文）</li><li>推理循环（用于追踪进展）</li></ul><p>ReAct 模式让你的智能体更具灵活性。它们不会拘泥于死板的流程，而是会仔细思考每一步，实时调整，并在出现新信息时及时修正方向。</p><p>如果你想构建的不只是一个能快速给出一次性答案的工具，那么这个模式就是你需要的。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250818203539.png"></p><hr><h3 id="四、规划（Planning）：Teach-Your-Agent-to-Think-Ahead"><a href="#四、规划（Planning）：Teach-Your-Agent-to-Think-Ahead" class="headerlink" title="四、规划（Planning）：Teach Your Agent to Think Ahead"></a>四、规划（Planning）：Teach Your Agent to Think Ahead</h3><p>大语言模型（LLMs）在快速给出答案方面表现还不错。但遇到需要多步骤处理的任务时？它们就力不从心了。而 <strong>规划（Planning）</strong>模式正好能解决这个问题。模型不会一次性尝试完成所有回答，而是会把目标拆解成更小、更容易处理的任务。</p><p>举个例子，如果有人问：“帮我发布一款产品。” 智能体可能会给出这样的步骤：</p><ol><li>确定目标受众</li><li>设计落地页</li><li>搭建邮件营销活动</li><li>撰写发布公告文案</li></ol><p>然后，它会一步一步地处理每个部分。规划模式能让你的智能体从一个被动响应的助手，转变为一个主动出击的执行者。对于工作流以及任何需要多步骤完成的任务来说，这个模式都非常适用。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250818203907.png"></p><hr><h3 id="五、多智能体（Multi-Agent）：Get-a-Team-Working-Together"><a href="#五、多智能体（Multi-Agent）：Get-a-Team-Working-Together" class="headerlink" title="五、多智能体（Multi-Agent）：Get a Team Working Together"></a>五、多智能体（Multi-Agent）：Get a Team Working Together</h3><p>当你可以拥有一整个团队协同工作时，为什么要依赖单个智能体呢？多智能体设置为不同的智能体分配不同的角色，每个智能体处理难题的一部分。它们相互协作 —— 有时甚至会争论 —— 以提出更好的解决方案。</p><p>给每个智能体一个名字和任务。让它们相互通信。看着它们反复尝试、批评并完善。当它们意见不一致时，神奇的事情就发生了。你会得到更敏锐的见解和更深入的思考。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250818204644.png"></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>智能体设计的关键不在于让模型变得更聪明，而在于构建更出色的系统。这类系统能够驾驭复杂性、在过程中灵活调整，并且不会因为第一个意外输入就崩溃。</p><p>这些模式让我不再将大语言模型（LLMs）视为魔法盒子，而是开始把它们看作更大流程中不够完美的组件。它们并非毫无瑕疵，但只要赋予其结构化的框架，就能释放强大的力量。因为真正的智能，存在于你为模型搭建的支撑架构中，而不仅仅是模型本身。</p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://medium.com/data-science-collective/stop-prompting-start-designing-5-agentic-ai-patterns-that-actually-work-a59c4a409ebb">Stop Prompting, Start Designing: 5 Agentic AI Patterns That Actually Work</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI" scheme="https://www.chanpoe.top/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.chanpoe.top/tags/AI/"/>
    
    <category term="Agent" scheme="https://www.chanpoe.top/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>代理与VPN</title>
    <link href="https://www.chanpoe.top/posts/7798897e.html"/>
    <id>https://www.chanpoe.top/posts/7798897e.html</id>
    <published>2025-04-28T02:44:30.000Z</published>
    <updated>2025-07-15T10:57:34.735Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="代理模式与VPN原理解析：如何高效解决常见网络问题"><a href="#代理模式与VPN原理解析：如何高效解决常见网络问题" class="headerlink" title="代理模式与VPN原理解析：如何高效解决常见网络问题"></a>代理模式与VPN原理解析：如何高效解决常见网络问题</h3><p>在网络使用过程中，我们时常会遇到各种代理和VPN相关的问题，如节点无法使用、特定软件无法正常工作、游戏无法连接等。这些问题的根本原因常常与代理模式和网络层的工作原理密切相关。本文将通过对不同代理模式的详细解析，帮助大家理解数据包如何通过代理或VPN流动，从而解决大部分网络使用中的问题。</p><hr><h3 id="一、家庭网络的基础架构"><a href="#一、家庭网络的基础架构" class="headerlink" title="一、家庭网络的基础架构"></a>一、家庭网络的基础架构</h3><p>首先，让我们从一个典型的家庭网络环境开始理解。家庭宽带通常由运营商提供并接入一个光猫，光猫再通过PPPoE拨号获取公网IP。之后，通过路由器将网络分发到家庭内部的各个设备，设备的内网IP通常是由路由器的DHCP服务自动分配的。路由器是家庭网络的核心，负责数据流的转发和NAT（网络地址转换）。</p><p>在这一过程中，当我们访问外部网站时，比如百度，浏览器发送请求，数据通过操作系统的网络协议栈层层封装，最终通过路由器发送到互联网，经过一系列的路由处理，最终到达目标服务器，完成数据的接收和响应。</p><hr><h3 id="二、常见的代理模式"><a href="#二、常见的代理模式" class="headerlink" title="二、常见的代理模式"></a>二、常见的代理模式</h3><h4 id="1-系统代理（SOCKS-HTTP代理）"><a href="#1-系统代理（SOCKS-HTTP代理）" class="headerlink" title="1. 系统代理（SOCKS/HTTP代理）"></a><strong>1. 系统代理（SOCKS/HTTP代理）</strong></h4><p>系统代理是最常见的一种代理方式。使用此方式时，代理客户端（如V2Ray或Clash）会接管操作系统的网络流量，并通过指定的代理服务器转发数据。大部分浏览器和一些网络应用程序可以通过系统代理设置，将请求交由代理客户端处理。</p><p>例如，使用V2Ray时，用户可以通过勾选“自动配置系统代理”，让系统中的所有网络请求（如浏览器访问谷歌）都经过V2Ray的代理节点。此时，V2Ray会根据分流规则判断是否需要走代理，若需要，则将数据进行加密封装，并通过指定节点发送出去。</p><p><strong>优点：</strong></p><ul><li>配置简单，适用于大部分普通应用。</li><li>使用方便，特别是浏览器等支持系统代理的程序。</li></ul><p><strong>缺点：</strong></p><ul><li>并不是所有软件都支持系统代理，尤其是一些特定的程序（如某些游戏和应用）。</li><li>系统代理通常只能处理HTTP和SOCKS协议，不支持UDP流量。</li></ul><h4 id="2-TUN-TAP模式（虚拟网卡代理）"><a href="#2-TUN-TAP模式（虚拟网卡代理）" class="headerlink" title="2. TUN/TAP模式（虚拟网卡代理）"></a><strong>2. TUN/TAP模式（虚拟网卡代理）</strong></h4><p>当系统代理无法满足需求时，可以使用TUN/TAP模式。此模式通过创建一个虚拟网卡，拦截并接管操作系统的所有网络流量，不管是浏览器、软件还是游戏，所有的流量都会经过这个虚拟网卡。此时，代理客户端（如Clash或V2Ray）将能够解析所有流量，并根据分流规则决定哪些流量需要通过代理。</p><p>在开启TUN/TAP模式后，操作系统的网络数据将不再直接发送到默认网关，而是先通过虚拟网卡进入代理程序进行处理。这种方式几乎可以接管系统中所有的网络流量，提供极高的灵活性。</p><p><strong>优点：</strong></p><ul><li>能够接管所有应用程序的流量，不受应用是否支持系统代理的限制。</li><li>支持更多协议，能够处理UDP流量，适用于对游戏等实时性要求较高的场景。</li></ul><p><strong>缺点：</strong></p><ul><li>配置较为复杂，可能需要管理员权限和额外的网络配置。</li><li>某些严格的程序或游戏可能会检测到虚拟网卡的存在，导致代理失效。</li></ul><h4 id="3-真·VPN（VPN模式）"><a href="#3-真·VPN（VPN模式）" class="headerlink" title="3. 真·VPN（VPN模式）"></a><strong>3. 真·VPN（VPN模式）</strong></h4><p>真·VPN代理主要应用于封装网络层的数据包，通过VPN隧道将数据传输到目标服务器。在此模式下，数据包不仅仅是简单的封装和加密，它能够覆盖操作系统层级的网络协议，如UDP等。因此，帧VPN对于需要完整网络层封装的应用（如PPTP、IPsec等）更为适合。</p><p>不同于普通的代理，VPN能够实现更深层次的网络层数据封装，支持所有类型的网络通信。它能够将局域网（LAN）设备连接到外部的虚拟网络中，实现内网穿透，特别适合有内网穿透需求的场景。</p><p><strong>优点：</strong></p><ul><li>完全封装网络层数据包，支持所有类型的网络协议。</li><li>能够实现内网穿透，提供虚拟私人网络服务。</li></ul><p><strong>缺点：</strong></p><ul><li>相比代理，VPN的配置和使用较为复杂，且大多数VPN协议（如IPsec、PPTP）不适合用于“翻墙”需求。</li><li>由于VPN协议的流量通常比较明显，容易被检测和限制。</li></ul><hr><h3 id="三、TUN模式与VPN的比较"><a href="#三、TUN模式与VPN的比较" class="headerlink" title="三、TUN模式与VPN的比较"></a>三、TUN模式与VPN的比较</h3><p>TUN模式和VPN在某些方面有相似之处，但也有本质的区别。TUN模式通过虚拟网卡拦截操作系统的网络流量，能够处理绝大多数应用程序的流量，并且在数据加密方面提供一定的灵活性。虽然它在处理复杂的流量时较为方便，但它并不完全封装网络层的数据包，因此对于需要完整网络层数据封装的应用（如某些VPN协议）来说，TUN模式并不是最理想的选择。</p><p>而真正的VPN，特别是像OpenVPN、L2TP等协议，能够封装网络层数据包，确保数据传输的安全和完整性，适用于一些需要实现内网穿透或更高安全性要求的场景。</p><hr><h3 id="四、透明代理：路由器与虚拟网卡的结合"><a href="#四、透明代理：路由器与虚拟网卡的结合" class="headerlink" title="四、透明代理：路由器与虚拟网卡的结合"></a>四、透明代理：路由器与虚拟网卡的结合</h3><p>为了实现完全透明的代理，某些家庭网络会将代理程序（如Clash或V2Ray）部署在路由器上，借助软路由技术实现全家联网的代理服务。这样，无论家庭中的设备是手机、电脑还是其他终端，都可以通过路由器接入代理，完全不需要单独配置每台设备的代理。</p><p>这种方式的优势在于，可以让所有设备通过统一的网关接入网络，避免了每个设备单独配置代理的麻烦，同时也能实现完全的流量分流和加密。然而，这种方案的实现需要支持软路由的路由器，且配置相对复杂。</p><hr><h3 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h3><p>通过深入理解代理模式、TUN/TAP模式与VPN的原理，我们可以更加清晰地看待和解决日常网络中的代理和VPN问题。无论是浏览网页、玩游戏还是进行内网穿透，不同的网络配置和代理模式都有其独特的优势和适用场景。了解这些基本原理，能够帮助我们更高效地解决代理使用中的各种问题，提升网络使用体验。</p><hr><h3 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h3><p><a href="https://www.youtube.com/watch?v=qItL005LUik">【进阶•代理模式篇】看懂就能解决99%的代理问题，详解系统代理、TUN/TAP代理、真VPN代理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://www.chanpoe.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="VPN" scheme="https://www.chanpoe.top/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Python包管理工具uv</title>
    <link href="https://www.chanpoe.top/posts/1ac4fef8.html"/>
    <id>https://www.chanpoe.top/posts/1ac4fef8.html</id>
    <published>2025-04-21T12:07:30.000Z</published>
    <updated>2025-05-08T15:57:21.661Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、新一代包管理工具uv"><a href="#一、新一代包管理工具uv" class="headerlink" title="一、新一代包管理工具uv"></a>一、新一代包管理工具uv</h3><p><code>Python</code> 包管理生态中存在多种工具，如 <code>pip</code>、<code>pip-tools</code>、<code>poetry</code>、<code>conda</code> 等，各自具备一定功能。</p><p>而今天介绍的<code>uv</code> 是 <code>Astral</code> 公司推出的一款基于 <code>Rust</code> 编写的 <code>Python</code> 包管理工具，旨在成为 “<strong>Python 的 Cargo</strong>”。</p><blockquote><p><code>Cargo</code> 是 Rust 编程语言的包管理和构建工具。它用于简化 Rust 项目的依赖管理、构建过程、测试和发布。 </p></blockquote><p>它提供了快速、可靠且易用的包管理体验，在性能、兼容性和功能上都有出色表现，为 <code>Python</code> 项目的开发和管理带来了新的选择。</p><p>✨与其他<code>Python</code>中的包管理工具相比，<code>uv</code>更像是一个全能选手，它的优势在于：</p><ol><li><p><strong>速度快</strong>：得益于<code>Rust</code>，<code>uv</code>工具的速度让人惊艳，比如安装依赖，速度比其他工具快很多</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250508234620.png"></p></li><li><p><strong>功能全面</strong>：<code>uv</code> 是“<strong>一站式服务</strong>”的工具，从安装 Python、管理虚拟环境，到安装和管理包，再到管理项目依赖，它统统都能处理得很好</p></li><li><p><strong>前景光明</strong>：背后有风投公司<code>Astral</code>支持，且采用了<code>MIT</code>许可，即使未来出现问题，社区也有应对的办法</p></li></ol><p>使用<code>uv</code>，也可以像<code>NodeJS</code>或者<code>Rust</code>项目那样方便的管理依赖。</p><hr><h3 id="二、一键安装"><a href="#二、一键安装" class="headerlink" title="二、一键安装"></a>二、一键安装</h3><blockquote><p>Github: <a href="https://github.com/astral-sh/uv">https://github.com/astral-sh/uv</a></p><p>Docs: <a href="https://docs.astral.sh/uv/">https://docs.astral.sh/uv/</a></p></blockquote><p>官方提供的一键安装脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># On macOS and Linux.</span><span class="token function">curl</span> <span class="token parameter variable">-LsSf</span> https://astral.sh/uv/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span class="token comment"># On Windows.</span>powershell <span class="token parameter variable">-ExecutionPolicy</span> ByPass <span class="token parameter variable">-c</span> <span class="token string">"irm https://astral.sh/uv/install.ps1 | iex"</span><span class="token comment"># With pip.</span>pip <span class="token function">install</span> uv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装之后，可以通过<code>uv help</code>命令检查是否安装成功</p><hr><h3 id="三、快速上手"><a href="#三、快速上手" class="headerlink" title="三、快速上手"></a>三、快速上手</h3><p>介绍<code>uv</code>工具主要使用的两个文件：</p><ul><li><code>pyproject.toml</code>：定义项目的主要依赖，包括项目名称、版本、描述、支持的 <code>Python</code> 版本等信息</li><li><code>uv.lock</code>：记录项目的所有依赖，包括依赖的依赖，且跨平台，确保在不同环境下安装的一致性。这个文件由 <code>uv</code> 自动管理，不要手动编辑</li></ul><p>使用<code>uv</code>创建项目</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 初始化一个名为 example 的新项目</span>$ uv init exampleInitialized project <span class="token variable"><span class="token variable">`</span>example<span class="token variable">`</span></span> at <span class="token variable"><span class="token variable">`</span>/home/user/example<span class="token variable">`</span></span>$ <span class="token builtin class-name">cd</span> example<span class="token comment"># 安装 ruff 包，它是一个 Python 代码检查工具。</span>$ uv <span class="token function">add</span> ruffCreating virtual environment at: .venvResolved <span class="token number">2</span> packages <span class="token keyword">in</span> 170ms   Built example @ file:///home/user/examplePrepared <span class="token number">2</span> packages <span class="token keyword">in</span> 627msInstalled <span class="token number">2</span> packages <span class="token keyword">in</span> 1ms + <span class="token assign-left variable">example</span><span class="token operator">==</span><span class="token number">0.1</span>.0 <span class="token punctuation">(</span>from file:///home/user/example<span class="token punctuation">)</span> + <span class="token assign-left variable">ruff</span><span class="token operator">==</span><span class="token number">0.5</span>.0<span class="token comment"># 运行 ruff 检查项目代码，确保没有错误。</span>$ uv run ruff checkAll checks passed<span class="token operator">!</span><span class="token comment"># 锁定当前项目的依赖版本，确保一致性。</span>$ uv lockResolved <span class="token number">2</span> packages <span class="token keyword">in</span> <span class="token number">0</span>.33ms<span class="token comment"># 同步项目依赖，确保依赖和锁文件一致。</span>$ uv <span class="token function">sync</span>Resolved <span class="token number">2</span> packages <span class="token keyword">in</span> <span class="token number">0</span>.70msAudited <span class="token number">1</span> package <span class="token keyword">in</span> <span class="token number">0</span>.02ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="四、使用方法"><a href="#四、使用方法" class="headerlink" title="四、使用方法"></a>四、使用方法</h3><h4 id="1-常用指令"><a href="#1-常用指令" class="headerlink" title="1. 常用指令"></a>1. 常用指令</h4><ol><li>查看pip包内容：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uv pip list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>全局安装第三方包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uv pip <span class="token function">install</span> <span class="token parameter variable">--system</span> requests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>查看可以更新的包</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uv pip list <span class="token parameter variable">--outdated</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li><code>uv</code>更新</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uv self update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>查看已安装的python版本</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uv python list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>安装/卸载python</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装python 3.12</span>uv python <span class="token function">install</span> <span class="token number">3.12</span><span class="token comment"># 卸载python 3.10</span>uv python uninstall <span class="token number">3.10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>初始化项目</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uv init project_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250508234318.png"></p><ol start="8"><li>为项目添加依赖</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uv <span class="token function">add</span> xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250508234424.png"></p><h4 id="2-详细介绍"><a href="#2-详细介绍" class="headerlink" title="2. 详细介绍"></a>2. 详细介绍</h4><blockquote><p><a href="https://docs.astral.sh/uv/getting-started/features/#python-versions">Python versions</a></p></blockquote><p>安装和管理 Python 本身。</p><ul><li><code>uv python install</code>：安装 Python 版本。</li><li><code>uv python list</code>：查看可用的 Python 版本。</li><li><code>uv python find</code>：查找已安装的 Python 版本。</li><li><code>uv python pin</code>：固定当前项目以使用特定的 Python 版本。</li><li><code>uv python uninstall</code>：卸载某个 Python 版本。</li></ul><p>请参阅<a href="https://docs.astral.sh/uv/guides/install-python/">安装 Python 的指南</a>来开始。</p><blockquote><p><a href="https://docs.astral.sh/uv/getting-started/features/#scripts">Scripts</a></p></blockquote><p>执行独立的 Python 脚本，例如<code>example.py</code>。</p><ul><li><code>uv run</code>：运行脚本。</li><li><code>uv add --script</code>：向脚本添加依赖项</li><li><code>uv remove --script</code>：从脚本中删除依赖项</li></ul><p>请参阅<a href="https://docs.astral.sh/uv/guides/scripts/">运行脚本的指南</a>来开始。</p><blockquote><p><a href="https://docs.astral.sh/uv/getting-started/features/#projects">Projects</a></p></blockquote><p>创建和处理 Python 项目，即使用<code>pyproject.toml</code>.</p><ul><li><code>uv init</code>：创建一个新的 Python 项目。</li><li><code>uv add</code>：向项目添加依赖项。</li><li><code>uv remove</code>：从项目中删除依赖项。</li><li><code>uv sync</code>：将项目的依赖项与环境同步。</li><li><code>uv lock</code>：为项目的依赖项创建一个锁文件。</li><li><code>uv run</code>：在项目环境中运行命令。</li><li><code>uv tree</code>：查看项目的依赖关系树。</li><li><code>uv build</code>：将项目构建到分发档案中。</li><li><code>uv publish</code>：将项目发布到包索引。</li></ul><p>请参阅<a href="https://docs.astral.sh/uv/guides/projects/">项目指南</a>以开始操作。</p><blockquote><p><a href="https://docs.astral.sh/uv/getting-started/features/#tools">Tools</a></p></blockquote><p>运行和安装发布到 Python 包索引的工具，例如<code>ruff</code>或<code>black</code>。</p><ul><li><code>uvx</code>/ <code>uv tool run</code>：在临时环境中运行工具。</li><li><code>uv tool install</code>：安装用户范围内的工具。</li><li><code>uv tool uninstall</code>：卸载工具。</li><li><code>uv tool list</code>：列出已安装的工具。</li><li><code>uv tool update-shell</code>：更新 shell 以包含工具可执行文件。</li></ul><p>请参阅<a href="https://docs.astral.sh/uv/guides/tools/">工具指南</a>以开始使用。</p><blockquote><p><a href="https://docs.astral.sh/uv/getting-started/features/#the-pip-interface">The pip interface</a></p></blockquote><p>手动管理环境和包 - 旨在用于传统工作流程或高级命令无法提供足够控制的情况。</p><p>创建虚拟环境（替换<code>venv</code>和<code>virtualenv</code>）：</p><ul><li><code>uv venv</code>：创建一个新的虚拟环境。</li></ul><p><a href="https://docs.astral.sh/uv/pip/environments/">有关详细信息，请参阅有关使用环境</a>的文档。</p><p>管理环境中的包（替换<a href="https://github.com/pypa/pip"><code>pip</code></a>和 <a href="https://github.com/tox-dev/pipdeptree"><code>pipdeptree</code></a>）：</p><ul><li><code>uv pip install</code>：将包安装到当前环境中。</li><li><code>uv pip show</code>：显示有关已安装软件包的详细信息。</li><li><code>uv pip freeze</code>：列出已安装的软件包及其版本。</li><li><code>uv pip check</code>：检查当前环境是否有兼容的包。</li><li><code>uv pip list</code>：列出已安装的软件包。</li><li><code>uv pip uninstall</code>：卸载软件包。</li><li><code>uv pip tree</code>：查看环境的依赖关系树。</li></ul><p><a href="https://docs.astral.sh/uv/pip/packages/">有关详细信息，请参阅管理包</a>的文档。</p><p>锁定环境中的包（替换<a href="https://github.com/jazzband/pip-tools"><code>pip-tools</code></a>）：</p><ul><li><code>uv pip compile</code>：将需求编译成锁文件。</li><li><code>uv pip sync</code>：使用锁文件同步环境。</li></ul><p><a href="https://docs.astral.sh/uv/pip/compile/">有关详细信息，请参阅锁定环境</a>的文档。</p><p>重要的</p><p>这些命令并未完全实现其所基于工具的接口和行为。您越偏离常用工作流程，就越有可能遇到差异。有关详细信息，请参阅<a href="https://docs.astral.sh/uv/pip/compatibility/">pip 兼容性指南</a>。</p><blockquote><p><a href="https://docs.astral.sh/uv/getting-started/features/#utility">Utility</a></p></blockquote><p>管理和检查 uv 的状态，例如缓存、存储目录或执行自我更新：</p><ul><li><code>uv cache clean</code>：删除缓存条目。</li><li><code>uv cache prune</code>：删除过时的缓存条目。</li><li><code>uv cache dir</code>：显示uv缓存目录路径。</li><li><code>uv tool dir</code>：显示uv工具目录路径。</li><li><code>uv python dir</code>：显示uv安装的Python版本路径。</li><li><code>uv self update</code>：更新uv到最新版本。</li></ul><p><a href="https://docs.astral.sh/uv/getting-started/features/#next-steps">Next steps</a></p><p>阅读<a href="https://docs.astral.sh/uv/guides/">指南</a>了解每个功能的介绍，查看 <a href="https://docs.astral.sh/uv/concepts/">概念</a>页面了解有关 uv 功能的详细信息，或者了解 在遇到任何问题时如何<a href="https://docs.astral.sh/uv/getting-started/help/">获得帮助</a></p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://docs.astral.sh/uv/getting-started/features/">uv 官方文档</a><br><a href="https://www.cnblogs.com/wang_yb/p/18635441">Python包管理不再头疼：uv工具快速上手</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="uv" scheme="https://www.chanpoe.top/tags/uv/"/>
    
  </entry>
  
  <entry>
    <title>使用 InnoSetup 制作安装包</title>
    <link href="https://www.chanpoe.top/posts/5d30c75b.html"/>
    <id>https://www.chanpoe.top/posts/5d30c75b.html</id>
    <published>2025-03-30T16:07:34.000Z</published>
    <updated>2025-03-30T16:42:06.872Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="InnoSetup-是什么？"><a href="#InnoSetup-是什么？" class="headerlink" title="InnoSetup 是什么？"></a>InnoSetup 是什么？</h3><p><strong>Inno Setup</strong> 是一款专为 Windows 平台设计的开源免费工具，用于<strong>将应用程序及其相关文件打包成专业的安装程序</strong>。使用脚本语言 （<code>.iss</code> 文件）自定义安装流程，支持灵活定制安装行为。</p><ul><li><a href="https://github.com/jrsoftware/issrc">https://github.com/jrsoftware/issrc</a></li></ul><p>但是<strong>它并不能帮你打包依赖</strong>，你需要自行先将程序的所有依赖寻找到，也就是做好“<em>打包</em>”，然后你才能使用它来生成一个安装包。</p><hr><h3 id="下载安装-InnoSetup"><a href="#下载安装-InnoSetup" class="headerlink" title="下载安装 InnoSetup"></a>下载安装 <code>InnoSetup</code></h3><p>我们可以通过官网去下载它的最新版本 <a href="https://files.jrsoftware.org/is/6/innosetup-6.4.2.exe"><code>innosetup-6.4.2.exe</code></a>。</p><p>安装没有什么好说的，一直点即可。</p><hr><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>你需要先将你的程序完全的打包好，比如你的 <code>.exe</code> 程序可能依赖许多的动态库、配置文件，均需要复制到同级目录。</p><p>然后新建一个目录，将除了程序本身的所有依赖放到另一个文件夹中。</p><hr><h3 id="添加中文语言支持"><a href="#添加中文语言支持" class="headerlink" title="添加中文语言支持"></a>添加中文语言支持</h3><p>Inno Setup 默认不包含中文语言包，需要手动下载<a href="https://raw.githubusercontent.com/jrsoftware/issrc/main/Files/Languages/Unofficial/ChineseSimplified.isl">简体中文翻译文件</a>。</p><p>下载后，将文件放入 Inno Setup 安装目录的 <code>Languages</code> 文件夹中。在该文件夹内，你会发现多个 <code>.isl</code> 文件，它们分别对应不同语言的翻译。</p><hr><h3 id="使用示例，为一个程序制作安装包"><a href="#使用示例，为一个程序制作安装包" class="headerlink" title="使用示例，为一个程序制作安装包"></a>使用示例，为一个程序制作安装包</h3><p>双击打开安装好的 Inno Setup Complier。</p><ol><li><p>然后选择使用安装向导的方式创建脚本，点击 OK 后开始。</p></li><li><p>填写程序相关信息：</p><p> <code>Application name</code> 应用程序的名字。<br> <code>Application version</code> 应用程序的版本号（v1.0）。<br> <code>Application publishe</code>r 应用的发布者。<br> <code>Application website</code> 应用程序的官网。</p></li><li><p><code>Application folder name</code> 是安装地址的文件夹名字，比如用户如何选择把程序安装到 <code>D:/</code> 那么就自动再创建一个文件夹（名字就是 <code>Application folder name</code>） 将程序放入，那么程序路径可能是：<code>D:/client/</code>。一般这个值可以不用改，就自动填上的程序名即可。</p></li><li><p>选择应用的执行文件，也就是启动程序 <code>.exe</code>；以及相关的资源文件和依赖。点击圈住的红色按钮进行设置，一个是可执行文件路径，一个是之前“<strong>前期准备</strong>”中创建的存放依赖的目录。</p></li></ol><hr><h3 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h3><p><a href="https://www.bilibili.com/video/BV1MZQ8YTEeg/?spm_id_from=333.337.search-card.all.click&amp;vd_source=75310977400d7b9e99795407c5732378">使用InnoSetup制作安装包进行发布</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="教程" scheme="https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="InnoSetup" scheme="https://www.chanpoe.top/tags/InnoSetup/"/>
    
  </entry>
  
  <entry>
    <title>配置SSH免密登录</title>
    <link href="https://www.chanpoe.top/posts/788b44f9.html"/>
    <id>https://www.chanpoe.top/posts/788b44f9.html</id>
    <published>2025-03-29T14:07:28.000Z</published>
    <updated>2025-03-30T15:09:23.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、具体步骤"><a href="#一、具体步骤" class="headerlink" title="一、具体步骤"></a>一、具体步骤</h3><ul><li>创建SSH密钥对（本地）：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">2048</span> <span class="token parameter variable">-C</span> <span class="token string">"xxxxxxxxx@email.xxx"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>复制公钥到远程服务器（本地）：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id username@remote_host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在本地的 SSH 配置文件<code>~/.ssh/config</code>中添加远程服务器的配置，以便更方便地连接：</li></ul><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250330215748.png"></p><blockquote><p>替换<code>远端ip或域名</code>为实际ip或域名，<code>chanpoe</code>为自定义远端别名，可以直接通过别名连接（见下图）</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host chanpoe    HostName 远端ip或域名    User user    IdentityFile ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/image-20250330220400606.png"></p><hr><h3 id="二、配置失败可能的问题"><a href="#二、配置失败可能的问题" class="headerlink" title="二、配置失败可能的问题"></a>二、配置失败可能的问题</h3><h4 id="1-远端未开启允许密钥认证"><a href="#1-远端未开启允许密钥认证" class="headerlink" title="1. 远端未开启允许密钥认证"></a>1. 远端未开启允许密钥认证</h4><p>确保远程服务器上的 SSH 服务配置文件 <code>/etc/ssh/sshd_config</code> 允许密钥认证。查找以下行，并确保它们没有被注释，并且设置正确：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PubkeyAuthentication <span class="token function">yes</span>AuthorizedKeysFile .ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果修改了 <code>/etc/ssh/sshd_config</code>则需要重启sshd服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart sshd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-权限问题"><a href="#2-权限问题" class="headerlink" title="2. 权限问题"></a>2. 权限问题</h4><p>在远程服务器上，确保用户的 <code>home </code>目录和<code>.ssh</code>目录的权限是正确的。运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh<span class="token function">chmod</span> <span class="token number">600</span> ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/2301_76437855/article/details/143749009">SSH免密登录（CSDN）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="教程" scheme="https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://www.chanpoe.top/tags/Linux/"/>
    
    <category term="SSH" scheme="https://www.chanpoe.top/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>搭建Minecraft Server</title>
    <link href="https://www.chanpoe.top/posts/936bc3bd.html"/>
    <id>https://www.chanpoe.top/posts/936bc3bd.html</id>
    <published>2025-02-13T16:07:34.000Z</published>
    <updated>2025-02-13T18:21:22.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Minecraft这个游戏属实让人着迷，每次都是突然想玩一下 -&gt; 玩一段时间 -&gt; 上瘾一段时间 -&gt; 变得不想玩，这个过程周而复始。。。</p><p>每次要玩的时候总得有个服务器吧，要不然怎么和小伙伴联机？客户端下载方便，都是<code>PCL启动器</code>一键下载，但是服务端部署起来可不是那么容易了。如果每次都搜索教程，杂七杂八拼凑着看教程总是让我抓狂，干脆就自己记录一下最新的搭建流程，方便未来想玩的时候随时可以回顾，那么开始吧！</p><blockquote><p>PS：本教程记录的是截至<code>2025年2月13日</code>最新版本的 <code>JDK23</code> + <code>Minecraft 1.21.4-Forge_54.0.7</code>部署服务器镜像版本：<code>Ubuntu 20.04</code></p></blockquote><h3 id="一、在服务器安装最新版JDK"><a href="#一、在服务器安装最新版JDK" class="headerlink" title="一、在服务器安装最新版JDK"></a>一、在服务器安装最新版JDK</h3><p>从官网下载最新版JDK：<a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a></p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250214001542.png"></p><p>服务器下载、解压JDK：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://download.oracle.com/java/23/latest/jdk-23_linux-x64_bin.tar.gz<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-23_linux-x64_bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将解压后的jdk文件夹移动到<code>/usr/local/java</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /usr/local/java<span class="token function">mv</span> jdk-23.0.2/ /usr/local/java/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250214003213.png"></p><p>修改环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~<span class="token function">vim</span> .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p> bashrc与profile都用于保存用户的环境信息，差异在于：</p><ol><li>bashrc是在系统启动后就会自动运行。</li><li>profile是在用户登录后才会运行。</li><li>进行设置后，可运用source bashrc命令更新bashrc，也可运用source profile命令更新profile。<br>  PS：通常我们修改bashrc,有些linux的发行版本不一定有profile这个文件</li><li>/etc/profile中设定的变量(全局)的可以作用于任何用户，而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量，他们是”父子”关系。</li></ol></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/java/jdk-23.0.2  <span class="token comment"># 记得改成自己的jdk安装路径</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">JRE_HOME</span><span class="token operator">=</span><span class="token variable">${JAVA_HOME}</span>/jre<span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>.:<span class="token variable">${JAVA_HOME}</span>/lib:<span class="token variable">${JRE_HOME}</span>/lib<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">${JAVA_HOME}</span>/bin:<span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250214005929.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看java环境是否成功安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">--version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250214010158.png"></p><hr><h3 id="二、下载jar文件，安装server-jar"><a href="#二、下载jar文件，安装server-jar" class="headerlink" title="二、下载jar文件，安装server.jar"></a>二、下载jar文件，安装server.jar</h3><p><a href="https://files.minecraftforge.net/net/minecraftforge/forge/">Forge | Installer</a></p><p>安装server.jar：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-jar</span> forge-x.xx.x-installer.jar <span class="token parameter variable">--installServer</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待安装完成：</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250214021530.png"></p><p>然后运行<code>run.sh</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./run.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行会提示修改<code>eula.txt</code>，将<code>eula</code>改为<code>true</code>再次运行<code>./run.sh</code>即可</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">#By changing the setting below to TRUE you are indicating your agreement to our EULA (https://aka.ms/MinecraftEULA).#Thu Feb 13 17:26:45 UTC 2025eula=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后编辑<code>server.properties</code>将<code>online_mode=true</code>改为<code>online_mode=false</code>就可以联机啦</p><blockquote><p><code>server.properties</code>其它参数设置参考：<a href="https://zh.minecraft.wiki/w/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">Minecraft wiki | 服务器配置文件格式</a></p></blockquote><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20250214021708.png"></p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_36449972/article/details/136644928">Ubuntu系统安装JDK</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="教程" scheme="https://www.chanpoe.top/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Minecraft" scheme="https://www.chanpoe.top/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>什么是RAG</title>
    <link href="https://www.chanpoe.top/posts/e5f27a74.html"/>
    <id>https://www.chanpoe.top/posts/e5f27a74.html</id>
    <published>2025-02-09T07:02:34.000Z</published>
    <updated>2025-03-30T16:58:06.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、什么是RAG"><a href="#一、什么是RAG" class="headerlink" title="一、什么是RAG"></a>一、什么是RAG</h3><p>检索增强生成（RAG）是指对大型语言模型输出进行优化，使其能够在生成响应之前引用训练数据来源之外的权威知识库。大型语言模型（LLM）用海量数据进行训练，使用数十亿个参数为回答问题、翻译语言和完成句子等任务生成原始输出。在 LLM 本就强大的功能基础上，RAG 将其扩展为能访问特定领域或组织的内部知识库，所有这些都无需重新训练模型。这是一种经济高效地改进 LLM 输出的方法，让它在各种情境下都能保持相关性、准确性和实用性。</p><hr><h3 id="二、RAG的重要性和好处"><a href="#二、RAG的重要性和好处" class="headerlink" title="二、RAG的重要性和好处"></a>二、RAG的重要性和好处</h3><h4 id="1-RAG的重要性"><a href="#1-RAG的重要性" class="headerlink" title="1. RAG的重要性"></a>1. RAG的重要性</h4><p>LLM 是一项关键的人工智能（AI）技术，为<strong>智能聊天机器人</strong>和其他<strong>自然语言处理（NLP）</strong>应用程序提供支持。目标是通过交叉引用权威知识来源，创建能够在各种环境中回答用户问题的机器人。不幸的是，LLM 技术的本质在 LLM 响应中引入了不可预测性。此外，LLM 训练数据是静态的，并引入了其所掌握知识的截止日期。</p><p>LLM 面临的已知挑战包括：</p><ul><li>在没有答案的情况下提供虚假信息（也称 大模型幻觉）。</li><li>当用户需要特定的当前响应时，提供过时或通用的信息。</li><li>从非权威来源创建响应。</li><li>由于术语混淆，不同的培训来源使用相同的术语来谈论不同的事情，因此会产生不准确的响应。</li></ul><p>您可以将大型语言模型看作是一个过于热情的新员工，他拒绝随时了解时事，但总是会绝对自信地回答每一个问题。不幸的是，这种态度会对用户的信任产生负面影响，这是您不希望聊天机器人效仿的！</p><p>RAG 是解决其中一些挑战的一种方法。它会重定向 LLM，从权威的、预先确定的知识来源中检索相关信息。组织可以更好地控制生成的文本输出，并且用户可以深入了解 LLM 如何生成响应。</p><h4 id="2-RAG的好处"><a href="#2-RAG的好处" class="headerlink" title="2. RAG的好处"></a>2. RAG的好处</h4><p>RAG 技术为组织的<strong>生成式人工智能</strong>工作带来了多项好处。</p><h5 id="经济高效的实施"><a href="#经济高效的实施" class="headerlink" title="经济高效的实施"></a><strong>经济高效的实施</strong></h5><p>聊天机器人开发通常从基础模型开始。基础模型（FM）是在广泛的广义和未标记数据上训练的 API 可访问 LLM。针对组织或领域特定信息重新训练 FM 的计算和财务成本很高。RAG 是一种将新数据引入 LLM 的更加经济高效的方法。它使生成式人工智能技术更广泛地获得和使用。</p><h5 id="当前信息"><a href="#当前信息" class="headerlink" title="当前信息"></a><strong>当前信息</strong></h5><p>即使 LLM 的原始训练数据来源适合您的需求，但保持相关性也具有挑战性。RAG 允许开发人员为生成模型提供最新的研究、统计数据或新闻。他们可以使用 RAG 将 LLM 直接连接到实时社交媒体提要、新闻网站或其他经常更新的信息来源。然后，LLM 可以向用户提供最新信息。</p><h5 id="增强用户信任度"><a href="#增强用户信任度" class="headerlink" title="增强用户信任度"></a><strong>增强用户信任度</strong></h5><p>RAG 允许 LLM 通过来源归属来呈现准确的信息。输出可以包括对来源的引文或引用。如果需要进一步说明或更详细的信息，用户也可以自己查找源文档。这可以增加对您的生成式人工智能解决方案的信任和信心。</p><h5 id="更多开发人员控制权"><a href="#更多开发人员控制权" class="headerlink" title="更多开发人员控制权"></a><strong>更多开发人员控制权</strong></h5><p>借助 RAG，开发人员可以更高效地测试和改进他们的聊天应用程序。他们可以控制和更改 LLM 的信息来源，以适应不断变化的需求或跨职能使用。开发人员还可以将敏感信息的检索限制在不同的授权级别内，并确保 LLM 生成适当的响应。此外，如果 LLM 针对特定问题引用了错误的信息来源，他们还可以进行故障排除并进行修复。组织可以更自信地为更广泛的应用程序实施生成式人工智能技术。</p><hr><h3 id="三、RAG的工作原理"><a href="#三、RAG的工作原理" class="headerlink" title="三、RAG的工作原理"></a>三、RAG的工作原理</h3><p>如果没有 RAG，LLM 会接受用户输入，并根据它所接受训练的信息或它已经知道的信息创建响应。RAG 引入了一个信息检索组件，该组件利用用户输入首先从新数据源提取信息。用户查询和相关信息都提供给 LLM。LLM 使用新知识及其训练数据来创建更好的响应。以下各部分概述了该过程。</p><h5 id="创建外部数据"><a href="#创建外部数据" class="headerlink" title="创建外部数据"></a><strong>创建外部数据</strong></h5><p>LLM 原始训练数据集之外的新数据称为<em>外部数据</em>。它可以来自多个数据来源，例如 API、数据库或文档存储库。数据可能以各种格式存在，例如文件、数据库记录或长篇文本。另一种称为<em>嵌入语言模型（Embedding Language Model）</em>的 AI 技术将数据转换为数字表示形式并将其存储在向量数据库中。这个过程会创建一个生成式人工智能模型可以理解的知识库。</p><blockquote><p> 嵌入语言模型（Embedding Language Model）是一种用于将文本数据转换为高维向量表示的人工智能技术。在该过程中，原始文本数据通过深度学习模型（如 Transformer、BERT 或 OpenAI 的 text-embedding-ada 系列）进行编码，映射到一个连续的向量空间。这些向量（即嵌入）捕捉了文本的语义信息，使得语义相似的文本在高维空间中距离更近。这些嵌入通常存储在<strong>向量数据库</strong>（Vector Database）中，如 FAISS、Weaviate 或 Pinecone，以便高效检索。</p><p>当生成式人工智能（Generative AI）模型需要查询外部知识时，它会将输入文本转换为向量，并在向量数据库中执行<strong>近似最近邻搜索（Approximate Nearest Neighbor, ANN）</strong>，检索与查询最相关的信息。这一机制通常用于<strong>增强检索（Retrieval-Augmented Generation, RAG）</strong>，以结合外部知识提升模型的生成能力。</p></blockquote><h5 id="检索相关信息"><a href="#检索相关信息" class="headerlink" title="检索相关信息"></a><strong>检索相关信息</strong></h5><p>下一步是执行相关性搜索。用户查询将转换为向量表示形式，并与向量数据库匹配。例如，考虑一个可以回答组织的人力资源问题的智能聊天机器人。如果员工搜索<em>：“我有多少年假？”</em>，系统将检索年假政策文件以及员工个人过去的休假记录。这些特定文件将被返回，因为它们与员工输入的内容高度相关。相关性是使用数学向量计算和表示法计算和建立的。</p><h5 id="增强-LLM-提示"><a href="#增强-LLM-提示" class="headerlink" title="增强 LLM 提示"></a><strong>增强 LLM 提示</strong></h5><p>接下来，RAG 模型通过在上下文中添加检索到的相关数据来增强用户输入（或提示）。此步骤使用<em>提示工程技术（Prompt Engineering）</em>与 LLM 进行有效沟通。增强提示允许大型语言模型为用户查询生成准确的答案。</p><blockquote><p><strong>提示工程（Prompt Engineering）\</strong>是一种优化输入提示（Prompt）以引导大语言模型（LLM）生成更精确、符合预期的输出的技术。它涉及对提示的**设计、优化和结构调整**，以最大化模型的性能。</p></blockquote><h5 id="更新外部数据"><a href="#更新外部数据" class="headerlink" title="更新外部数据"></a><strong>更新外部数据</strong></h5><p>下一个问题可能是——如果外部数据过时了怎么办？ 要维护当前信息以供检索，请异步更新文档并更新文档的嵌入表示形式。您可以通过自动化实时流程或定期批处理来执行此操作。这是数据分析中常见的挑战——可以使用不同的数据科学方法进行变更管理。</p><p>下图显示了将 RAG 与 LLM 配合使用的概念流程。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://docs.aws.amazon.com/images/sagemaker/latest/dg/images/jumpstart/jumpstart-fm-rag.jpg"></p><h3 id="四、RAG和语义搜索的区别"><a href="#四、RAG和语义搜索的区别" class="headerlink" title="四、RAG和语义搜索的区别"></a>四、RAG和语义搜索的区别</h3><p>语义搜索可以提高 RAG 结果，适用于想要在其 LLM 应用程序中添加大量外部知识源的组织。现代企业在各种系统中存储大量信息，例如手册、常见问题、研究报告、客户服务指南和人力资源文档存储库等。上下文检索在规模上具有挑战性，因此会降低生成输出质量。</p><p>语义搜索技术可以扫描包含不同信息的大型数据库，并更准确地检索数据。例如，他们可以回答诸如 <em>“去年在机械维修上花了多少钱？”</em>之类的问题，方法是将问题映射到相关文档并返回特定文本而不是搜索结果。然后，开发人员可以使用该答案为 LLM 提供更多上下文。</p><p>RAG 中的传统或关键字搜索解决方案对知识密集型任务产生的结果有限。开发人员在手动准备数据时还必须处理单词嵌入、文档分块和其他复杂问题。相比之下，语义搜索技术可以完成知识库准备的所有工作，因此开发人员不必这样做。它们还生成语义相关的段落和按相关性排序的标记词，以最大限度地提高 RAG 有效载荷的质量。</p><blockquote><h5 id="什么时候用-RAG，什么时候用语义搜索？"><a href="#什么时候用-RAG，什么时候用语义搜索？" class="headerlink" title="什么时候用 RAG，什么时候用语义搜索？"></a><strong>什么时候用 RAG，什么时候用语义搜索？</strong></h5><ul><li><strong>如果只是查找相关文档</strong> → ✅ <strong>语义搜索</strong></li><li><strong>如果需要 AI 生成基于检索信息的完整答案</strong> → ✅ <strong>RAG</strong></li></ul><p><strong>🔹 例如：</strong></p><ul><li><strong>搜索产品规格？</strong> → 语义搜索（返回产品文档）</li><li><strong>问“这两个产品有什么区别？”</strong> → RAG（检索文档 + 生成答案）</li></ul></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://aws.amazon.com/what-is/retrieval-augmented-generation/">什么是 RAG（检索增强生成）？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="AI" scheme="https://www.chanpoe.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>pydantic库</title>
    <link href="https://www.chanpoe.top/posts/acb99ef9.html"/>
    <id>https://www.chanpoe.top/posts/acb99ef9.html</id>
    <published>2024-07-30T08:24:39.000Z</published>
    <updated>2024-11-19T12:49:44.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>数据验证：可以定义数据模型并对数据进行验证。</li><li>数据序列化：可以将数据序列化为JSON等格式。</li><li>数据转换：可以将数据转换为特定类型。</li><li>默认值和选项：可以设置字段的默认值和选项。</li><li>异常处理：可以处理数据验证过程中的异常情况。</li></ul><hr><h3 id="BaseModel类"><a href="#BaseModel类" class="headerlink" title="BaseModel类"></a>BaseModel类</h3><ol><li>用于定义数据模型，并且对数据进行验证：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">id</span><span class="token punctuation">:</span> <span class="token builtin">int</span>    username<span class="token punctuation">:</span> <span class="token builtin">str</span>    email<span class="token punctuation">:</span> <span class="token builtin">str</span>user1_dict <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">'username'</span><span class="token punctuation">:</span> <span class="token string">'Chanpoe'</span><span class="token punctuation">,</span>    <span class="token string">'email'</span><span class="token punctuation">:</span> <span class="token string">'chanpoe@example.com'</span><span class="token punctuation">}</span>user1 <span class="token operator">=</span> User<span class="token punctuation">(</span><span class="token operator">**</span>user1_dict<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>用于数据序列化，将数据序列化为JSON等格式：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>user1<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 得到结果：{"id": 1, "username": "Chanpoe", "email": "chanpoe@example.com"}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>   将用户对象序列化为JSON格式的数据，方便网络传输使用。</p><hr><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>数据验证</li></ol><p>用来验证用户输入数据的合法性，保证数据符合预期格式和规则：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token punctuation">,</span> EmailStr<span class="token punctuation">,</span> validator<span class="token comment"># 自定义校验器（见下文高级功能介绍）</span><span class="token keyword">class</span> <span class="token class-name">UserRegistration</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    username<span class="token punctuation">:</span> <span class="token builtin">str</span>    email<span class="token punctuation">:</span> EmailStr    password<span class="token punctuation">:</span> <span class="token builtin">str</span>    <span class="token comment"># 验证用户密码不能小于8位，并且要同时有数字和字母</span>    <span class="token decorator annotation punctuation">@validator</span><span class="token punctuation">(</span><span class="token string">'password'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">validate_password</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'密码不能小于8位'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">any</span><span class="token punctuation">(</span>char<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> char <span class="token keyword">in</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'密码必须包含数字'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">any</span><span class="token punctuation">(</span>char<span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> char <span class="token keyword">in</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'密码必须包含字母'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> value<span class="token comment"># 处理用户注册请求</span><span class="token keyword">def</span> <span class="token function">register_user</span><span class="token punctuation">(</span>user_data<span class="token punctuation">:</span> <span class="token builtin">dict</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>user_data<span class="token punctuation">)</span>    user <span class="token operator">=</span> UserRegistration<span class="token punctuation">(</span><span class="token operator">**</span>user_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>    <span class="token comment"># 处理注册逻辑</span>    <span class="token keyword">return</span> <span class="token string">"User registered successfully"</span><span class="token comment"># 示例请求数据</span>request_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"username"</span><span class="token punctuation">:</span> <span class="token string">"john_doe"</span><span class="token punctuation">,</span> <span class="token string">"email"</span><span class="token punctuation">:</span> <span class="token string">"john.doe@example.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">:</span> <span class="token string">'chanpoezhang123'</span><span class="token punctuation">}</span>result <span class="token operator">=</span> register_user<span class="token punctuation">(</span>request_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>API参数处理</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI<span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token punctuation">,</span> constrapp <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">UserSearch</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    keyword<span class="token punctuation">:</span> constr<span class="token punctuation">(</span>min_length<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>post</span><span class="token punctuation">(</span><span class="token string">"/search"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">search_users</span><span class="token punctuation">(</span>search_data<span class="token punctuation">:</span> UserSearch<span class="token punctuation">)</span><span class="token punctuation">:</span>    keyword <span class="token operator">=</span> search_data<span class="token punctuation">.</span>keyword    <span class="token comment"># 处理搜索逻辑</span>    <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"Searching users with keyword: </span><span class="token interpolation"><span class="token punctuation">{</span>keyword<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token comment"># 示例请求数据</span>request_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"keyword"</span><span class="token punctuation">:</span> <span class="token string">"john"</span><span class="token punctuation">}</span>result <span class="token operator">=</span> search_users<span class="token punctuation">(</span>request_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><ol><li>自定义校验器：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">UserRegistration</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    username<span class="token punctuation">:</span> <span class="token builtin">str</span>    email<span class="token punctuation">:</span> EmailStr    password<span class="token punctuation">:</span> <span class="token builtin">str</span>    <span class="token comment"># 验证用户密码不能小于8位，并且要同时有数字和字母</span>    <span class="token decorator annotation punctuation">@validator</span><span class="token punctuation">(</span><span class="token string">'password'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">validate_password</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'密码不能小于8位'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">any</span><span class="token punctuation">(</span>char<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> char <span class="token keyword">in</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'密码必须包含数字'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">any</span><span class="token punctuation">(</span>char<span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> char <span class="token keyword">in</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'密码必须包含字母'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>继承、扩展模型</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    username<span class="token punctuation">:</span> <span class="token builtin">str</span>    email<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token keyword">class</span> <span class="token class-name">AdminUser</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span><span class="token punctuation">:</span>    role<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token comment"># 创建管理员用户对象并进行数据验证</span>admin_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"username"</span><span class="token punctuation">:</span> <span class="token string">"admin_user"</span><span class="token punctuation">,</span> <span class="token string">"email"</span><span class="token punctuation">:</span> <span class="token string">"admin@example.com"</span><span class="token punctuation">,</span> <span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"admin"</span><span class="token punctuation">}</span>admin_user <span class="token operator">=</span> AdminUser<span class="token punctuation">(</span><span class="token operator">**</span>admin_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>admin_user<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>自定义序列化器和反序列化器</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token punctuation">,</span> root_validator<span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    username<span class="token punctuation">:</span> <span class="token builtin">str</span>    email<span class="token punctuation">:</span> <span class="token builtin">str</span>    <span class="token decorator annotation punctuation">@root_validator</span>    <span class="token keyword">def</span> <span class="token function">to_xml</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">:</span>        xml_str <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"&lt;user&gt;&lt;username&gt;</span><span class="token interpolation"><span class="token punctuation">{</span>values<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">&lt;/username&gt;&lt;email&gt;</span><span class="token interpolation"><span class="token punctuation">{</span>values<span class="token punctuation">[</span><span class="token string">'email'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">&lt;/email&gt;&lt;/user&gt;"</span></span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"xml_data"</span><span class="token punctuation">:</span> xml_str<span class="token punctuation">}</span><span class="token comment"># 创建用户对象并进行数据转换</span>user_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"username"</span><span class="token punctuation">:</span> <span class="token string">"john_doe"</span><span class="token punctuation">,</span> <span class="token string">"email"</span><span class="token punctuation">:</span> <span class="token string">"john.doe@example.com"</span><span class="token punctuation">}</span>user <span class="token operator">=</span> User<span class="token punctuation">(</span><span class="token operator">**</span>user_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>xml_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://zhuanlan.zhihu.com/p/696103020">pydantic，一个超强的 Python 库！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="pydantic" scheme="https://www.chanpoe.top/tags/pydantic/"/>
    
  </entry>
  
  <entry>
    <title>selenium手册</title>
    <link href="https://www.chanpoe.top/posts/9c0d5c1.html"/>
    <id>https://www.chanpoe.top/posts/9c0d5c1.html</id>
    <published>2024-07-30T07:25:03.000Z</published>
    <updated>2024-11-19T12:49:44.367Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="爬虫常用的option备份"><a href="#爬虫常用的option备份" class="headerlink" title="爬虫常用的option备份"></a>爬虫常用的option备份</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">options <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>ChromeOptions<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 无头模式</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--headless"</span><span class="token punctuation">)</span><span class="token comment"># 无沙盒模式</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--no-sandbox'</span><span class="token punctuation">)</span><span class="token comment"># 默认情况下，Chrome 使用 /dev/shm（共享内存）来提高性能，但在内存有限的系统中（如 Docker 容器），可能需要禁用</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--disable-dev-shm-usage'</span><span class="token punctuation">)</span><span class="token comment"># 禁用所有 Chrome 扩展</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--disable-extensions'</span><span class="token punctuation">)</span><span class="token comment"># 防止网站检测到自动化工具（即 WebDriver）</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--disable-blink-features=AutomationControlled"</span><span class="token punctuation">)</span><span class="token comment"># 禁用 GPU 硬件加速，在某些环境中（特别是无头模式），禁用 GPU 可以避免一些不兼容问题。</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">"--disable-gpu"</span><span class="token punctuation">)</span><span class="token comment"># 当 DOMContentLoaded 事件触发时，Selenium 会认为页面加载完成，适合对页面完全加载不敏感的场景，可以提高效率。</span>options<span class="token punctuation">.</span>page_load_strategy <span class="token operator">=</span> <span class="token string">'eager'</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>    <span class="token string">"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"</span><span class="token punctuation">)</span><span class="token comment"># 添加代理</span>options<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"--proxy-server=</span><span class="token interpolation"><span class="token punctuation">{</span>proxy_ip<span class="token punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token punctuation">{</span>proxy_port<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">driver<span class="token punctuation">.</span>switch_to<span class="token punctuation">.</span>window<span class="token punctuation">(</span>driver<span class="token punctuation">.</span>window_handles<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用远程selenium-driver"><a href="#使用远程selenium-driver" class="headerlink" title="使用远程selenium driver"></a>使用远程selenium driver</h3><pre class="line-numbers language-none"><code class="language-none"># Selenium Grid地址command_executor = "http://selenium example.com/wd/hub"# driver = webdriver.Remote(command_executor=command_executor, options=options)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="显式等待某个元素加载"><a href="#显式等待某个元素加载" class="headerlink" title="显式等待某个元素加载"></a>显式等待某个元素加载</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 等待搜索框元素加载完成</span>WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>presence_of_element_located<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>XPATH<span class="token punctuation">,</span> <span class="token string">"//*[@class='search-wrapper main-search white']"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="selenium" scheme="https://www.chanpoe.top/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>pillow库</title>
    <link href="https://www.chanpoe.top/posts/dfa16b65.html"/>
    <id>https://www.chanpoe.top/posts/dfa16b65.html</id>
    <published>2024-07-11T01:47:12.000Z</published>
    <updated>2024-11-19T12:49:44.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Python2中，PIL(Python Imaging Library)是一个非常好用的图像处理库，但PIL不支持Python3，所以有人(Alex Clark和Contributors)提供了Pillow，可以在Python3中使用。  </p><hr><h3 id="一、安装pillow库："><a href="#一、安装pillow库：" class="headerlink" title="一、安装pillow库："></a>一、安装pillow库：</h3><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pip install pillow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Pillow库安装成功后，导包时要用PIL来导入，而不能用pillow或Pillow。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> PIL<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最常用的就是Image类，pillow库中的其他很多模块都是在Image的基础上对图像做进一步的处理。</p><hr><h3 id="二、打开一张图片："><a href="#二、打开一张图片：" class="headerlink" title="二、打开一张图片："></a>二、打开一张图片：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Imageimage <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.png"</span><span class="token punctuation">)</span>image<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、创建一张图片："><a href="#三、创建一张图片：" class="headerlink" title="三、创建一张图片："></a>三、创建一张图片：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Imageimage <span class="token operator">=</span> Image<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">'RGB'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>image<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>new(mode, size, color=0)</code>: 创建一张图片(画布)，用于绘图，是Image模块中的函数。有3个参数。</p><p>mode, 图片的模式，如“RGB”(red,green,blue三原色的缩写，真彩图像)、“L”(灰度，黑白图像)等。</p><p><code>size</code>, 图片的尺寸。是一个长度为2的元组(width, height)，表示的是像素大小。</p><p><code>color</code>, 图片的颜色，默认值为0表示黑色。可以传入长度为3的元组表示颜色，也可以传入颜色的十六进制，在版本1.1.4后，还可以直接传入颜色的英文单词，如上面代码中的(0, 0, 255)可以换成‘#0000FF’或‘blue’，都是表示蓝色。</p><hr><h3 id="四、Image模块常用的属性"><a href="#四、Image模块常用的属性" class="headerlink" title="四、Image模块常用的属性:"></a>四、Image模块常用的属性:</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Imageimage <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"text_effect.png"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'width: '</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'height: '</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'size: '</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'mode: '</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'format: '</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">)</span><span class="token comment"># print('category: ', image.category)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'readonly: '</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>readonly<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'info: '</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>info<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>width</code>属性表示图片的像素宽度，height属性表示图片的像素高度，width和height组成了size属性，size是一个元组。</p><p><code>mode</code>属性表示图片的模式，如RGBA，RGB，P，L等。</p><p>图片的模式可以参考：</p><p><a href="https://pillow.readthedocs.io/en/latest/handbook/concepts.html#concept-modes">https://pillow.readthedocs.io/en/latest/handbook/concepts.html#concept-modes</a></p><p><code>format</code>属性表示图片的格式，格式一般与图片的后缀扩展名相关。category属性表示图片的的类别。</p><p><code>readonly</code>属性表述图片是否为只读，值为1或0，表示的是布尔值。</p><p><code>info</code>属性表示图片的信息，是一个字典。</p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://cloud.tencent.com/developer/article/1794195">Python Pillow(PIL)库的用法介绍</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="pillow" scheme="https://www.chanpoe.top/tags/pillow/"/>
    
  </entry>
  
  <entry>
    <title>Git 代码规范</title>
    <link href="https://www.chanpoe.top/posts/af9fde63.html"/>
    <id>https://www.chanpoe.top/posts/af9fde63.html</id>
    <published>2024-05-16T08:52:09.000Z</published>
    <updated>2025-07-15T10:00:09.313Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git-代码规范指南"><a href="#Git-代码规范指南" class="headerlink" title="Git 代码规范指南"></a>Git 代码规范指南</h1><p>本指南介绍了 Git Commit 的标准写法以及常见分支的命名规则，帮助团队统一代码管理流程。</p><hr><h2 id="📝-Git-Commit-Message-规范"><a href="#📝-Git-Commit-Message-规范" class="headerlink" title="📝 Git Commit Message 规范"></a>📝 Git Commit Message 规范</h2><p>一个规范的提交信息包括：</p><pre class="line-numbers language-none"><code class="language-none">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-type（类型）"><a href="#1-type（类型）" class="headerlink" title="1. type（类型）"></a>1. <code>type</code>（类型）</h3><p>用于说明本次提交的目的：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>feat</code></td><td>✨ 新功能</td></tr><tr><td><code>fix</code> / <code>to</code></td><td>🐞 修复 Bug（<code>fix</code>：自动修复；<code>to</code>：逐步修复）</td></tr><tr><td><code>docs</code></td><td>📝 修改文档</td></tr><tr><td><code>style</code></td><td>💄 代码格式（无功能变更）</td></tr><tr><td><code>refactor</code></td><td>♻️ 代码重构（非功能修改）</td></tr><tr><td><code>perf</code></td><td>⚡ 性能优化</td></tr><tr><td><code>test</code></td><td>✅ 添加或修改测试</td></tr><tr><td><code>chore</code></td><td>🔧 构建或辅助工具变动</td></tr><tr><td><code>revert</code></td><td>⏪ 回滚上一个版本</td></tr><tr><td><code>merge</code></td><td>🔀 合并代码</td></tr><tr><td><code>sync</code></td><td>🔄 同步主线或分支的 Bug</td></tr><tr><td><code>improvement</code></td><td>🔨 功能改进</td></tr><tr><td><code>ci</code></td><td>🛠️ 持续集成相关改动</td></tr><tr><td><code>build</code></td><td>📦 打包相关变动</td></tr></tbody></table><hr><h3 id="2-scope（可选范围）"><a href="#2-scope（可选范围）" class="headerlink" title="2. scope（可选范围）"></a>2. <code>scope</code>（可选范围）</h3><p>用于说明影响范围，写在括号中。例如：</p><ul><li><code>feat(login)</code>：登录模块的功能新增  </li><li><code>fix(api)</code>：API 模块的 Bug 修复</li></ul><hr><h3 id="3-subject（简短说明）"><a href="#3-subject（简短说明）" class="headerlink" title="3. subject（简短说明）"></a>3. <code>subject</code>（简短说明）</h3><p>一句话描述本次提交的目的，<strong>不超过 50 个字符</strong>，<strong>结尾不加标点</strong>。</p><p>✅ 示例：</p><pre class="line-numbers language-none"><code class="language-none">fix(DAO): 用户查询缺少 username 属性  feat(Controller): 开发用户查询接口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="4-body（详细描述）"><a href="#4-body（详细描述）" class="headerlink" title="4. body（详细描述）"></a>4. <code>body</code>（详细描述）</h3><p>用于说明此次提交的背景、目的与改动点。<br>建议每行不超过 72 个字符。</p><hr><h3 id="5-footer（脚注说明）"><a href="#5-footer（脚注说明）" class="headerlink" title="5. footer（脚注说明）"></a>5. <code>footer</code>（脚注说明）</h3><p>用于关联 Issue、记录重大变更：</p><ul><li><p><strong>关联 Issue</strong>：<br><code>Closes #123</code> 或 <code>Fixes #123</code></p></li><li><p><strong>破坏性变更</strong>：<br><code>BREAKING CHANGE: &lt;说明&gt;</code></p></li></ul><hr><h2 id="🌿-分支命名规范"><a href="#🌿-分支命名规范" class="headerlink" title="🌿 分支命名规范"></a>🌿 分支命名规范</h2><p>为了保证代码协作有序，约定如下分支命名方式：</p><h3 id="1-main-master：主分支"><a href="#1-main-master：主分支" class="headerlink" title="1. main / master：主分支"></a>1. <code>main</code> / <code>master</code>：主分支</h3><ul><li><strong>用途</strong>：发布稳定版本代码  </li><li><strong>规则</strong>：禁止直接提交，只能通过合并其他分支更新</li></ul><hr><h3 id="2-develop：开发分支"><a href="#2-develop：开发分支" class="headerlink" title="2. develop：开发分支"></a>2. <code>develop</code>：开发分支</h3><ul><li><strong>用途</strong>：集成功能分支开发成果  </li><li><strong>规则</strong>：从 <code>main</code> 创建，所有功能合并回 <code>develop</code></li></ul><hr><h3 id="3-feature-或-feat-：功能分支"><a href="#3-feature-或-feat-：功能分支" class="headerlink" title="3. feature/ 或 feat/：功能分支"></a>3. <code>feature/</code> 或 <code>feat/</code>：功能分支</h3><ul><li><strong>命名</strong>：<code>feature/&lt;功能名&gt;</code> 或 <code>feat/&lt;功能名&gt;</code>  </li><li><strong>规则</strong>：从 <code>develop</code> 创建，合并回 <code>develop</code>  </li><li>✅ 示例：<br><code>feature/user-authentication</code><br><code>feat/add-payment-gateway</code></li></ul><hr><h3 id="4-bugfix-或-fix-：Bug-修复分支"><a href="#4-bugfix-或-fix-：Bug-修复分支" class="headerlink" title="4. bugfix/ 或 fix/：Bug 修复分支"></a>4. <code>bugfix/</code> 或 <code>fix/</code>：Bug 修复分支</h3><ul><li><strong>规则</strong>：从 <code>develop</code> 创建，修复后合并回 <code>develop</code>  </li><li>✅ 示例：<br><code>bugfix/login-error</code><br><code>fix/null-pointer-exception</code></li></ul><hr><h3 id="5-release-：发布分支"><a href="#5-release-：发布分支" class="headerlink" title="5. release/：发布分支"></a>5. <code>release/</code>：发布分支</h3><ul><li><strong>规则</strong>：从 <code>develop</code> 创建，发布后合并回 <code>main</code> 与 <code>develop</code>  </li><li>✅ 示例：<br><code>release/v1.0.0</code><br><code>release/2023-10-01</code></li></ul><hr><h3 id="6-hotfix-：紧急修复分支"><a href="#6-hotfix-：紧急修复分支" class="headerlink" title="6. hotfix/：紧急修复分支"></a>6. <code>hotfix/</code>：紧急修复分支</h3><ul><li><strong>规则</strong>：从 <code>main</code> 创建，修复后合并回 <code>main</code> 和 <code>develop</code>  </li><li>✅ 示例：<br><code>hotfix/critical-security-issue</code><br><code>hotfix/login-page-crash</code></li></ul><hr><h3 id="7-support-：旧版本维护分支"><a href="#7-support-：旧版本维护分支" class="headerlink" title="7. support/：旧版本维护分支"></a>7. <code>support/</code>：旧版本维护分支</h3><ul><li><strong>规则</strong>：从 <code>main</code> 创建，用于维护旧版本  </li><li>✅ 示例：<br><code>support/v1.0.x</code></li></ul><hr><h2 id="🚀-分支命名最佳实践"><a href="#🚀-分支命名最佳实践" class="headerlink" title="🚀 分支命名最佳实践"></a>🚀 分支命名最佳实践</h2><table><thead><tr><th>建议</th><th>示例</th></tr></thead><tbody><tr><td>使用小写 + 连字符</td><td><code>feature/user-authentication</code></td></tr><tr><td>避免空格或特殊符号</td><td>❌ <code>feature/User Authentication</code></td></tr><tr><td>包含上下文和任务号</td><td><code>feature/PROJ-123-add-search</code></td></tr><tr><td>保持简洁</td><td>✅ <code>fix/api-timeout</code>；❌ <code>fix/api-request-timeout-due-to-long-queue</code></td></tr></tbody></table><hr><h2 id="📌-推荐工作流参考图"><a href="#📌-推荐工作流参考图" class="headerlink" title="📌 推荐工作流参考图"></a>📌 推荐工作流参考图</h2><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/e5f5568e0c1859a6c47b45a77f51490b.jpg"></p><hr><p>通过规范化 Git 提交流程和分支管理，团队协作会更加高效统一，利于代码审查和版本追踪。如有需要，也可以将此规范集成到 CI 流程中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习记录" scheme="https://www.chanpoe.top/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Git" scheme="https://www.chanpoe.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式使用手册</title>
    <link href="https://www.chanpoe.top/posts/82f2334a.html"/>
    <id>https://www.chanpoe.top/posts/82f2334a.html</id>
    <published>2024-04-29T03:05:43.000Z</published>
    <updated>2025-03-30T16:57:01.301Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="在线工具（2024-11-19更新）"><a href="#在线工具（2024-11-19更新）" class="headerlink" title="在线工具（2024.11.19更新）"></a>在线工具（2024.11.19更新）</h3><p><a href="https://www.jyshare.com/front-end/854/">正则表达式在线测试</a></p><p><a href="https://r2coding.com/#/README?id=%e5%b8%b8%e7%94%a8%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e7%a4%ba%e4%be%8b">常用正则表达式</a></p><blockquote><p> 推荐阅读：<a href="https://www.chanpoe.top/posts/2f57a694.html">Python 正则表达式（本站）</a></p></blockquote><hr><h3 id="基础匹配模式"><a href="#基础匹配模式" class="headerlink" title="基础匹配模式"></a>基础匹配模式</h3><table><thead><tr><th align="left">实例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>.</code></td><td align="left">匹配除 “\n” 之外的任何单个字符 要匹配包括 ‘\n’ 在内的任何字符，请使用像 ‘[.\n]’ 的模式</td></tr><tr><td align="left"><code>?</code></td><td align="left">匹配一个字符零次或一次，另一个作用是非贪婪模式</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配1次或多次</td></tr><tr><td align="left"><code>*</code></td><td align="left">匹配0次或多次</td></tr><tr><td align="left"><code>\b</code></td><td align="left">匹配一个长度为<code>0</code>的子串</td></tr><tr><td align="left"><code>\d</code></td><td align="left">匹配一个数字字符 等价于 [0-9]</td></tr><tr><td align="left"><code>\D</code></td><td align="left">匹配一个非数字字符 等价于 [^0-9]</td></tr><tr><td align="left"><code>\s</code></td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等 等价于 [ \f\n\r\t\v]</td></tr><tr><td align="left"><code>\S</code></td><td align="left">匹配任何非空白字符 等价于 [^ \f\n\r\t\v]</td></tr><tr><td align="left"><code>\w</code></td><td align="left">匹配包括下划线的任何单词字符 等价于 [A-Za-z0-9_]</td></tr><tr><td align="left"><code>\W</code></td><td align="left">匹配任何非单词字符 等价于 [^A-Za-z0-9_]</td></tr><tr><td align="left"><code>[Pp]ython</code></td><td align="left">匹配 “Python” 或 “python”</td></tr><tr><td align="left"><code>[abcdef]</code></td><td align="left">匹配中括号内的任意一个字母</td></tr><tr><td align="left"><code>[0-9]</code></td><td align="left">匹配任何数字 类似于 [0123456789]</td></tr><tr><td align="left"><code>[a-z]</code></td><td align="left">匹配任何小写字母</td></tr><tr><td align="left"><code>[A-Z]</code></td><td align="left">匹配任何大写字母</td></tr><tr><td align="left"><code>[a-zA-Z0-9]</code></td><td align="left">匹配任何字母及数字</td></tr><tr><td align="left"><code>[^au]</code></td><td align="left">除了au字母以外的所有字符</td></tr><tr><td align="left"><code>[^0-9]</code></td><td align="left">匹配除了数字外的字符</td></tr></tbody></table><p>在Python中，正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">re.I</td><td align="left">使匹配对大小写不敏感</td></tr><tr><td align="left">re.L</td><td align="left">做本地化识别（locale-aware）匹配</td></tr><tr><td align="left">re.M</td><td align="left">多行匹配，影响 ^ 和 $</td></tr><tr><td align="left">re.S</td><td align="left">使 . 匹配包括换行在内的所有字符</td></tr><tr><td align="left">re.U</td><td align="left">根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td align="left">re.X</td><td align="left">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><hr><h3 id="高级匹配模式"><a href="#高级匹配模式" class="headerlink" title="高级匹配模式"></a>高级匹配模式</h3><h4 id="1-分组与非捕获组（2024-11-19更新）"><a href="#1-分组与非捕获组（2024-11-19更新）" class="headerlink" title="1. 分组与非捕获组（2024.11.19更新）"></a>1. 分组与非捕获组（2024.11.19更新）</h4><h5 id="1-分组（捕获组）"><a href="#1-分组（捕获组）" class="headerlink" title="1. 分组（捕获组）"></a>1. 分组（捕获组）</h5><p>语法：<code>()</code></p><p>介绍：同时匹配多块内容，方便引用，捕获，提取对应的内容</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240430171629.png"></p><p>这段正则表达式将文本<strong>分成了两组</strong>，第一组为：<code>0731</code>，第二组为<code>8825951</code>。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240430171648.png"></p><h5 id="2-非捕获组"><a href="#2-非捕获组" class="headerlink" title="2. 非捕获组"></a>2. 非捕获组</h5><p>语法：<code>(?:...)</code></p><p>介绍：不同于<code>()</code>的捕获功能，<code>(?:)</code>用于将一些表达式组合在一起，作为一个整体进行匹配，但不会捕获匹配的内容。</p><p>优势：（Generated By Doubao）</p><ul><li>提高性能：<ul><li>在一些复杂的正则表达式中，如果不需要捕获某些分组内容，使用<code>(?:)</code>可以减少正则表达式引擎需要保存的中间结果，从而提高匹配效率。例如，在一个需要匹配大量文本的场景中，存在很多分组，但只有部分分组的内容是后续需要使用的，对于那些不需要使用的分组，使用非捕获分组可以节省内存和时间。</li></ul></li><li>简化反向引用逻辑：<ul><li>有时候我们只是想将一些表达式组合起来进行匹配，而不想让这些分组干扰反向引用。例如，在一个复杂的表达式<code>(?:abc|def)+\d</code>中，我们只是想匹配<code>abc</code>或<code>def</code>出现一次或多次后跟着一个数字的情况，这里使用<code>(?:)</code>可以避免创建不必要的捕获分组，使正则表达式的逻辑更清晰，因为如果使用普通的捕获分组，可能会导致意外的反向引用或者混淆真正需要引用的分组。</li></ul></li></ul><h4 id="2-先行断言"><a href="#2-先行断言" class="headerlink" title="2. 先行断言"></a>2. 先行断言</h4><p>很多人也称先行断言和后行断言为<strong>环视</strong>，也有人叫<strong>预搜索</strong>，其实叫什么无所谓，重要的是知道如何使用它们！</p><blockquote><p>先行断言和后行断言总共有四种：</p><ol><li>正向先行断言</li><li>反向先行断言</li><li>正向后行断言</li><li>反向后行断言</li></ol></blockquote><h5 id="2-1-正向先行断言"><a href="#2-1-正向先行断言" class="headerlink" title="2.1 正向先行断言"></a>2.1 正向先行断言</h5><p><strong>正向先行断言：</strong><code>(?=表达式)</code>，指在某个位置向右看，表示所在位置右侧必须能匹配<code>表达式</code></p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要取出<strong>喜欢</strong>两个字，要求这个<strong>喜欢</strong>后面有你，这个时候就要这么写：<code>喜欢(?=你)</code>，这就是<strong>正向先行断言</strong>。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://cdn.codejiaonang.com/download/cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL-WFiOihjOaWreiogC5wbmc=" alt="start"></p><p><strong>例：提取包含大小写字母的字符串</strong></p><p>先行断言可以用来判断字符串是否符合特定的规则，例如提取包含至少一个大小写字母的字符串：</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://cdn.codejiaonang.com/download/cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL-WFiOihjOaWreiogDIucG5n" alt="start"></p><p><code>(?=.*?[a-z])(?=.*?[A-Z]).+</code> 这段正则表达式规定了匹配的字符串中必须包含<strong>至少一个大写和小写的字母</strong>。</p><h5 id="2-1-反向先行断言"><a href="#2-1-反向先行断言" class="headerlink" title="2.1 反向先行断言"></a>2.1 反向先行断言</h5><p><strong>反向先行断言</strong><code>(?!表达式)</code>的作用是保证右边不能出现某字符。</p><p>例如： <code>我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你</code></p><p>如果要取出<strong>喜欢</strong>两个字，要求这个<strong>喜欢</strong>后面没有你，这个时候就要这么写：<code>喜欢(?!你)</code>，这就是<strong>反向先行断言</strong>。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240430172037.png"></p><h4 id="3-后行断言"><a href="#3-后行断言" class="headerlink" title="3.后行断言"></a>3.后行断言</h4><h5 id="3-1-正向后行断言"><a href="#3-1-正向后行断言" class="headerlink" title="3.1 正向后行断言"></a>3.1 正向后行断言</h5><p>只需要你记住一句话：先行断言和后行断言只有一个区别，即<strong>先行断言从左往右看，后行断言从右往左看。</strong></p><p><strong>正向后行断言：</strong><code>(?&lt;=表达式)</code>，指在某个位置向左看，表示所在位置左侧必须能匹配<code>表达式</code></p><p>例如：如果要取出喜欢两个字，要求喜欢的<strong>前面有我</strong>，<strong>后面有你</strong>，这个时候就要这么写：<code>(?&lt;=我)喜欢(?=你)</code>。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240430172256.png"></p><h5 id="3-2-反向后行断言"><a href="#3-2-反向后行断言" class="headerlink" title="3.2 反向后行断言"></a>3.2 反向后行断言</h5><p><strong>反向后行断言：</strong><code>(?&lt;!表达式)</code>，指在某个位置向左看，表示所在位置左侧不能匹配<code>表达式</code></p><p>例如：如果要取出喜欢两个字，要求喜欢的<strong>前面没有我</strong>，<strong>后面没有你</strong>，这个时候就要这么写：<code>(?&lt;!我)喜欢(?!你)</code>。</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240430172319.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Regex" scheme="https://www.chanpoe.top/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>fastapi库</title>
    <link href="https://www.chanpoe.top/posts/eac2f9d3.html"/>
    <id>https://www.chanpoe.top/posts/eac2f9d3.html</id>
    <published>2024-04-26T08:15:32.000Z</published>
    <updated>2024-11-19T12:49:44.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我有一个很棒的服务想分享给别人用，但是因为对方的环境和我不一样，当然不能再花时间和精力装环境咯，而且假如我的服务是运行在4090上的，软件环境好解决，可是硬件环境。。。</p><p>说了这么多，可见API的重要性。何为API？如果你在百度百科上搜索，你会得到如下结果：<strong>API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</strong>。通俗一点说，用户可以将自己的服务封装，向外部提供一个接口，然后别人可以通过接口使用你的服务，大大节省了时间和精力。</p><hr><h3 id="一、FastAPI库介绍"><a href="#一、FastAPI库介绍" class="headerlink" title="一、FastAPI库介绍"></a>一、FastAPI库介绍</h3><p>FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.8+ based on standard Python type hints.</p><p>什么，看不懂英文？👉🏻<a href="https://fanyi.baidu.com/">https://fanyi.baidu.com/</a></p><p>不管学什么语言，都应该至少掌握一个框架，方面我们后续，进行服务部署、服务对外支持等</p><blockquote><p> <strong>FastAPI的优势</strong>：</p><ul><li><strong>快速</strong>：可与 <strong>NodeJS</strong> 和 <strong>Go</strong> 并肩的极高性能（归功于 <code>Starlette 和 Pydantic</code>）。<a href="https://fastapi.tiangolo.com/zh/#_11">最快的 Python web 框架之一</a>。</li><li><strong>高效编码</strong>：提高功能开发速度约 200％ 至 300％。</li><li><strong>更少 bug</strong>：减少约 40％ 的人为（开发者）导致错误。</li><li><strong>智能</strong>：极佳的编辑器支持。处处皆可自动补全，减少调试时间。</li><li><strong>简单</strong>：设计的易于使用和学习，阅读文档的时间更短。</li><li><strong>简短</strong>：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。</li><li><strong>健壮</strong>：生产可用级别的代码。还有自动生成的交互式文档。</li><li><strong>标准化</strong>：基于（并完全兼容）API 的相关开放标准：<a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a> (以前被称为 <code>Swagger</code>) 和 <a href="https://json-schema.org/">JSON Schema</a>。</li></ul></blockquote><ul><li><a href="https://fastapi.tiangolo.com/zh/">官方文档:https://fastapi.tiangolo.com/zh/</a></li></ul><hr><h3 id="二、启动一个ASGI服务器："><a href="#二、启动一个ASGI服务器：" class="headerlink" title="二、启动一个ASGI服务器："></a>二、启动一个ASGI服务器：</h3><p>你还会需要一个 ASGI 服务器，生产环境可以使用 <a href="https://www.uvicorn.org/">Uvicorn</a> 或者 <a href="https://gitlab.com/pgjones/hypercorn">Hypercorn</a>。</p><pre class="line-numbers language-none"><code class="language-none">pip install "uvicorn[standard]"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑<code>test.py</code>测试文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> Union<span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPIapp <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">read_root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">:</span> <span class="token string">"World"</span><span class="token punctuation">}</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>get</span><span class="token punctuation">(</span><span class="token string">"/items/{item_id}"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">read_item</span><span class="token punctuation">(</span>item_id<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> Union<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"item_id"</span><span class="token punctuation">:</span> item_id<span class="token punctuation">,</span> <span class="token string">"q"</span><span class="token punctuation">:</span> q<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动服务器：</p><pre class="line-numbers language-none"><code class="language-none">uvicorn test:app --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>PS：可以设置端口和HOST：</p><pre class="line-numbers language-none"><code class="language-none">uvicorn test:app --reload --port 3359 --host 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240426171014.png"></p><p>使用浏览器访问： <a href="http://127.0.0.1:8000/items/5?q=somequery">http://127.0.0.1:8000/items/5?q=somequery</a></p><p>会看到如下JSON响应：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"item_id"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">"somequery"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你已经创建了一个具有以下功能的 API：</p><ul><li>通过 路径 / 和 /items/{item_id} 接受 HTTP 请求。</li><li>以上 路径 都接受 GET 操作（也被称为 HTTP 方法）。</li><li>/items/{item_id} 路径 有一个 路径参数 item_id 并且应该为 int 类型。</li><li>/items/{item_id} 路径 有一个可选的 str 类型的 查询参数 q。</li></ul><hr><h3 id="三、交互式API文档："><a href="#三、交互式API文档：" class="headerlink" title="三、交互式API文档："></a>三、交互式API文档：</h3><p>现在访问 <a href="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a></p><p>你会看到自动生成的交互式 API 文档（由 <a href="https://github.com/swagger-api/swagger-ui">Swagger UI</a>生成）</p><p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240426170923.png"></p><blockquote><ul><li><code>SwaggerUi风格文档:</code><a href="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a></li><li><code>ReDoc风格文档：</code><a href="http://127.0.0.1:8000/redoc">http://127.0.0.1:8000/redoc</a></li></ul></blockquote><ul><li>如何关闭文档生成?</li></ul><p>如果不想生成交互式文档,可以通过以下方式实例化<code>FastAPI</code>:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># docs_url=None: 代表关闭SwaggerUi</span><span class="token comment"># redoc_url=None: 代表关闭redoc文档</span>app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span>docs_url<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> redoc_url<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/tiangolo/fastapi">https://github.com/tiangolo/fastapi</a></p><p><a href="https://zhuanlan.zhihu.com/p/667041110">https://zhuanlan.zhihu.com/p/667041110</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="fastapi" scheme="https://www.chanpoe.top/tags/fastapi/"/>
    
  </entry>
  
  <entry>
    <title>Python代码模板</title>
    <link href="https://www.chanpoe.top/posts/b6650cca.html"/>
    <id>https://www.chanpoe.top/posts/b6650cca.html</id>
    <published>2024-04-11T15:18:30.000Z</published>
    <updated>2024-11-19T12:49:44.358Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># coding: utf-8</span><span class="token comment"># Author：Chanpoe</span><span class="token comment"># Date ：$DATE $TIME</span><span class="token comment"># IDE：${PRODUCT_NAME}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在Pycharm中保存Python代码模板，下面是新建<code>test.py</code>文件的效果：</p><img src="https://image-bed.obs.cn-north-4.myhuaweicloud.com/loading.gif" data-original="https://image-bed.obs.cn-north-4.myhuaweicloud.com/20240411232042.png" style="zoom: 67%;"><hr><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://www.cnblogs.com/lifengjuan/p/17685306.html">Pycharm创建文件时，自动生成文件头注释（作者、日期等信息）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="代码模板" scheme="https://www.chanpoe.top/tags/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>glob库</title>
    <link href="https://www.chanpoe.top/posts/fe032ba7.html"/>
    <id>https://www.chanpoe.top/posts/fe032ba7.html</id>
    <published>2024-04-02T01:10:32.000Z</published>
    <updated>2024-11-19T12:49:44.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>平时我都是使用os库对文件进行读取和操作，今天偶然从别人那里学到了一个很好用的库，翻阅了几篇资料教程，发现确实方便很多。glob库可以用类似正则表达式的方式来匹配文件和目录，确实不戳，收至麾下。</p><hr><h3 id="一、glob库介绍"><a href="#一、glob库介绍" class="headerlink" title="一、glob库介绍"></a>一、glob库介绍</h3><p><code>glob</code>库是Python的一个标准库，他提供了简单强大的匹配文件和目录的方法。</p><p>通常情况下，在命令行中使用通配符来搜索文件，例如<code>*.txt</code>来匹配所有以<code>.txt</code>为后缀的文件。<code>glob</code>库允许我们以编程的方式在Python脚本中执行类似的文件匹配操作。</p><hr><h3 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h3><h4 id="1-使用通配符匹配文件"><a href="#1-使用通配符匹配文件" class="headerlink" title="1. 使用通配符匹配文件"></a>1. 使用通配符匹配文件</h4><p><code>glob</code>库使用通配符来匹配文件和目录。下面是一些常用的通配符(类似正则)：</p><ul><li><code>*</code>：匹配0个或多个字符。</li><li><code>?</code>：匹配单个字符。</li><li><code>[]</code>：匹配指定范围内的字符，如<code>[0-9]</code>匹配所有数字字符。</li></ul><p>让我们来看一个例子。假设我们有一个文件夹data，其中包含以下文件：</p><pre class="line-numbers language-none"><code class="language-none">data/    file1.txt    file2.txt    image.jpg    data.csv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们想要匹配所有以<code>.txt</code>为后缀的文件。我们可以使用<code>*.txt</code>作为模式字符串：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">txt_files <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"data/*.txt"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>txt_files<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">['data/file1.txt', 'data/file2.txt']<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>正如我们所见，<code>glob.glob()</code>函数返回了一个列表，其中包含了所有以.txt为后缀的文件路径。</p><h4 id="2-匹配特定目录"><a href="#2-匹配特定目录" class="headerlink" title="2. 匹配特定目录"></a>2. 匹配特定目录</h4><p>如果我们希望匹配的文件在子目录中，我们可以使用双星号<code>**</code>来进行递归搜索。例如，假设我们有以下文件结构：</p><pre class="line-numbers language-none"><code class="language-none">data/    file1.txt    subdir/        file2.txt        file3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们想要匹配所有以<code>.txt</code>为后缀的文件，不论它们位于哪个子目录中。我们可以使用<code>**/*.txt</code>作为模式字符串：</p><pre class="line-numbers language-none"><code class="language-none">txt_files_recursive = glob.glob("data/**/*.txt", recursive=True)print(txt_files_recursive)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">['data/file1.txt', 'data/subdir/file2.txt', 'data/subdir/file3.txt']<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>recursive=True</code>参数，我们可以匹配到所有子目录中的文件。</p><h4 id="3-匹配多种后缀（错误，不能这样写）"><a href="#3-匹配多种后缀（错误，不能这样写）" class="headerlink" title="3. 匹配多种后缀（错误，不能这样写）"></a>3. 匹配多种后缀（错误，不能这样写）</h4><p><del>有时候我们需要匹配多种后缀的文件，可以使用<code>[]</code>来指定匹配的范围。例如，如果我们想要匹配<code>.txt</code>和<code>.csv</code>文件，我们可以使用<code>["*.txt", "*.csv"]</code>作为模式字符串：</del></p><p>如果想要匹配以 .csv 或 .txt 结尾的文件，需要进行两次单独的 glob 调用，然后将结果合并。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># txt_and_csv_files = glob.glob("data/*.[txt|csv]")</span><span class="token comment"># print(txt_and_csv_files)</span><span class="token keyword">import</span> globcsv_files <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./data/*.csv'</span><span class="token punctuation">)</span>txt_files <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./data/*.txt'</span><span class="token punctuation">)</span>files_list <span class="token operator">=</span> csv_files <span class="token operator">+</span> txt_files<span class="token keyword">print</span><span class="token punctuation">(</span>files_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-获取目录列表"><a href="#4-获取目录列表" class="headerlink" title="4. 获取目录列表"></a>4. 获取目录列表</h4><p>除了匹配文件，<code>glob</code>库还可以获取目录列表。如果我们想要列出所有子目录，可以使用<code>*/</code>作为模式字符串：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">subdirs <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"data/*/"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>subdirs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">['data/subdir/']<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-使用iglob-进行迭代"><a href="#5-使用iglob-进行迭代" class="headerlink" title="5. 使用iglob()进行迭代"></a>5. 使用<code>iglob()</code>进行迭代</h4><p>对于大型目录，一次性获取所有匹配的文件列表可能会占据大量内存。在这种情况下，可以使用<code>iglob()</code>函数来进行迭代获取。<code>iglob()</code>返回一个迭代器，逐个返回匹配的文件名。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">txt_files_iterator <span class="token operator">=</span> glob<span class="token punctuation">.</span>iglob<span class="token punctuation">(</span><span class="token string">"data/*.txt"</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> txt_files_iterator<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">data/file1.txtdata/file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>iglob()</code>适用于处理大量文件时，可以节省内存开销。</p><hr><h3 id="三、过滤和排序匹配结果"><a href="#三、过滤和排序匹配结果" class="headerlink" title="三、过滤和排序匹配结果"></a>三、过滤和排序匹配结果</h3><h4 id="1-过滤匹配结果"><a href="#1-过滤匹配结果" class="headerlink" title="1. 过滤匹配结果"></a>1. 过滤匹配结果</h4><p><code>glob</code>库允许我们使用<code>fnmatch</code>模块的匹配方法来过滤匹配结果。例如，假设我们只想匹配以<code>file</code>开头的文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> glob<span class="token keyword">import</span> fnmatch<span class="token comment"># 获取所有以'file'开头的文件</span>file_starting_with_file <span class="token operator">=</span> fnmatch<span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"data/*"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"file*"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>file_starting_with_file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">['data/file1.txt', 'data/file2.txt']<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-排序匹配结果"><a href="#2-排序匹配结果" class="headerlink" title="2. 排序匹配结果"></a>2. 排序匹配结果</h4><p>glob库返回的匹配结果通常是按照操作系统的文件系统规则排序的。但是有时候我们可能需要按照自定义的方式对结果排序，因此我们可以使用python内置的<code>sorted()</code>函数对匹配结果进行排序。</p><p>例如，我们按照文件大小对匹配的文件进行排序：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> glob<span class="token keyword">import</span> os<span class="token comment"># 获取匹配的文件并按照文件大小排序</span>matched_files <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"data/*.txt"</span><span class="token punctuation">)</span>sorted_files_by_size <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>matched_files<span class="token punctuation">,</span> key<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>getsize<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>sorted_files_by_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">['data/file1.txt', 'data/file2.txt']<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们使用<code>os.path.getsize</code>作为<code>sorted()</code>函数的<code>key</code>参数，从而按照文件的大小对匹配结果进行排序。</p><h4 id="3-自定义匹配规则"><a href="#3-自定义匹配规则" class="headerlink" title="3. 自定义匹配规则"></a>3. 自定义匹配规则</h4><p><code>glob</code>库允许我们使用自定义函数来对匹配的结果进行过滤和排序。例如，假设我们想要匹配所有以奇数数字结尾的文件，并且按照数字大小进行排序：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> glob<span class="token comment"># 自定义过滤函数</span><span class="token keyword">def</span> <span class="token function">custom_filter</span><span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    filename <span class="token operator">=</span> file_path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    last_char <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>filename<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 获取文件名中的最后一个数字</span>    <span class="token keyword">return</span> last_char<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">int</span><span class="token punctuation">(</span>last_char<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token comment"># 获取匹配的文件并按照自定义规则排序</span>matched_files <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"data/*"</span><span class="token punctuation">)</span>filtered_and_sorted_files <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">filter</span><span class="token punctuation">(</span>custom_filter<span class="token punctuation">,</span> matched_files<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>filtered_and_sorted_files<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>过滤函数custom_filter()用来过滤以奇数数字结尾的文件，并使用sorted()函数按照自定义规则进行排序。</p><h4 id="4-遍历子目录中的文件（已经用os-walk-替代）"><a href="#4-遍历子目录中的文件（已经用os-walk-替代）" class="headerlink" title="4. 遍历子目录中的文件（已经用os.walk()替代）"></a>4. 遍历子目录中的文件（已经用<code>os.walk()</code>替代）</h4><p><del>前面使用<code>**</code>来进行递归搜索，但如果只希望遍历子目录中的文件而不进一步进入子目录，可以使用<code>glob.glob()</code>结合<code>os.path.join()</code>来实现。</del></p><p>现已更换<code>os.walk()</code>：</p><p>假设目录结构如下：</p><pre class="line-numbers language-none"><code class="language-none">data/    file1.txt    subdir1/        file2.txt        file3.txt    subdir2/        file4.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># import glob</span><span class="token comment"># import os</span><span class="token comment"># </span><span class="token comment"># def list_files_in_directory(directory):</span><span class="token comment">#     files = []</span><span class="token comment">#     for file_path in glob.glob(os.path.join(directory, "*")):</span><span class="token comment">#         if os.path.isfile(file_path):</span><span class="token comment">#             files.append(file_path)</span><span class="token comment">#     return files</span><span class="token comment"># </span><span class="token comment"># directory_path = "data"</span><span class="token comment"># files_in_directory = list_files_in_directory(directory_path)</span><span class="token comment"># print(files_in_directory)</span><span class="token comment"># os.walk()更好用</span><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">list_all_files</span><span class="token punctuation">(</span>directory<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> dirpath<span class="token punctuation">,</span> dirnames<span class="token punctuation">,</span> filenames <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>directory<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> filename <span class="token keyword">in</span> filenames<span class="token punctuation">:</span>            <span class="token keyword">yield</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dirpath<span class="token punctuation">,</span> filename<span class="token punctuation">)</span>directory_path <span class="token operator">=</span> <span class="token string">"data"</span>all_files <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>list_all_files<span class="token punctuation">(</span>directory_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>all_files<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">['data/file1.txt', 'data/subdir1/file2.txt', 'data/subdir1/file3.txt', 'data/subdir2/file4.txt']<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这个例子中，我们定义了一个<code>list_files_in_directory()</code>函数，该函数遍历指定目录中的文件，并忽略子目录。使用<code>os.path.join()</code>函数来构建文件路径，确保可以正确处理不同操作系统下的路径分隔符。</p><h3 id="四、使用glob库进行文件处理"><a href="#四、使用glob库进行文件处理" class="headerlink" title="四、使用glob库进行文件处理"></a>四、使用glob库进行文件处理</h3><p><code>glob</code>库不仅仅用于匹配和获取文件列表，还可以方便地进行文件处理。我们可以将<code>glob</code>库与其他的python库（例如os、shutil等）结合使用，来执行各种文件操作。</p><h4 id="1-复制文件"><a href="#1-复制文件" class="headerlink" title="1. 复制文件"></a>1. 复制文件</h4><p>假设我们想将所有以<code>.txt</code>为后缀的文件复制到另一个目录中，我们可以使用<code>shutil</code>库来实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> glob<span class="token keyword">import</span> shutilsource_directory <span class="token operator">=</span> <span class="token string">"data"</span>destination_directory <span class="token operator">=</span> <span class="token string">"backup"</span>txt_files <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>source_directory<span class="token punctuation">,</span> <span class="token string">"*.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> txt_file <span class="token keyword">in</span> txt_files<span class="token punctuation">:</span>    shutil<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>txt_file<span class="token punctuation">,</span> destination_directory<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们首先使用<code>glob</code>库来获取所有以<code>.txt</code>为后缀的文件列表，然后使用<code>shutil.copy()</code>函数将这些文件复制到<code>backup</code>目录中。</p><h4 id="2-删除文件"><a href="#2-删除文件" class="headerlink" title="2. 删除文件"></a>2. 删除文件</h4><p>如果我们希望删除所有以<code>.csv</code>为后缀的文件，可以使用<code>os.remove()</code>函数来实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> glob<span class="token keyword">import</span> oscsv_files <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"data/*.csv"</span><span class="token punctuation">)</span><span class="token keyword">for</span> csv_file <span class="token keyword">in</span> csv_files<span class="token punctuation">:</span>    os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>csv_file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-批量重命名文件"><a href="#3-批量重命名文件" class="headerlink" title="3. 批量重命名文件"></a>3. 批量重命名文件</h4><p><code>glob</code>库与字符串处理和<code>os.rename()</code>函数结合使用，可以批量重命名文件。假设我们有一系列文件名格式为<code>file_&lt;num&gt;.txt</code>（例如<code>file_1.txt</code>、<code>file_2.txt</code>等），现在我们希望将它们重命名为<code>data_&lt;num&gt;.txt</code>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> globold_names <span class="token operator">=</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'data/*.txt'</span><span class="token punctuation">)</span>new_names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'data/t1.txt'</span><span class="token punctuation">,</span> <span class="token string">'data/t2.txt'</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>old_names<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>new_names<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The number of old file names and new file names does not match."</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> old_name<span class="token punctuation">,</span> new_name <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>old_names<span class="token punctuation">,</span> new_names<span class="token punctuation">)</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>old_name<span class="token punctuation">,</span> new_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_21484461/article/details/131908308">【实用 Python 库】Python glob库：轻松应对文件和目录管理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="glob" scheme="https://www.chanpoe.top/tags/glob/"/>
    
  </entry>
  
  <entry>
    <title>Python loguru库</title>
    <link href="https://www.chanpoe.top/posts/e686f33a.html"/>
    <id>https://www.chanpoe.top/posts/e686f33a.html</id>
    <published>2024-02-04T05:37:41.000Z</published>
    <updated>2025-03-30T15:43:04.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>单纯的使用python自带的print函数只能在控制台看到用户指定的输出结果，但是，print函数弊端十分明显，它不能很好的输出运行的时间，并且当前运行的module、function、行号都无法用print函数很方便的打印输出，最重要的是，如果想要将打印输出的内容输出到日志文件，操作起来就变得十分棘手。<br>引入日志功能，不但可以很好的解决上述print函数的各种问题，而且loguru这个库提供了十分方便的使用方案，十分容易上手。</p><h3 id="一、loguru库的使用："><a href="#一、loguru库的使用：" class="headerlink" title="一、loguru库的使用："></a>一、loguru库的使用：</h3><blockquote><p>python自带了logging的模块，但是需要进行复杂的配置才能很好的使用，也是与我们的初心相违背。使用loguru库可以进行简单的配置完成用户的需求。</p></blockquote><ul><li>安装loguru模块</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> loguru<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>举一个简单的例子：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> loguru <span class="token keyword">import</span> loggerlogger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Hello world!'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>执行结果：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2024</span>-02-04 <span class="token number">13</span>:48:37.575 <span class="token operator">|</span> INFO     <span class="token operator">|</span> __main__:<span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>:21 - Hello world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>输出到日志文件：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> loguru <span class="token keyword">import</span> loggerlogger<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"日志文件.log"</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">"成功写入日志文件！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优雅的loguru<code>format</code>格式：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 相对位置 ./logs/日志文件.log</span>logger<span class="token punctuation">.</span>add<span class="token punctuation">(</span>sink<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">,</span> <span class="token string">'日志文件.log'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>               <span class="token builtin">format</span><span class="token operator">=</span><span class="token string">r"{time:YYYY-MM-DD HH:mm:ss} | "</span>                      <span class="token string">"{level: &lt;5} \t| "</span>                      <span class="token string">"{module}.{function}:{line} - {message}"</span><span class="token punctuation">,</span>               encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">,</span> level<span class="token operator">=</span><span class="token string">"INFO"</span><span class="token punctuation">,</span> enqueue<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> retention<span class="token operator">=</span><span class="token string">"10 days"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="二、日志层级（Level）："><a href="#二、日志层级（Level）：" class="headerlink" title="二、日志层级（Level）："></a>二、日志层级（Level）：</h3><p>Loguru提供了七层日志层级，或者说七种日志类型。  </p><p>生产环境中，常常在不同场景下使用不用的日志类型，用于处理各种问题。  </p><p>每种类型的日志有一个整数值，表示日志层级，我们成为log level no。  </p><ul><li><code>TRACE (5)</code>: 用于记录程序执行路径的细节信息，以进行诊断。  </li><li><code>DEBUG (10)</code>: 开发人员使用该工具记录调试信息。  </li><li><code>INFO (20)</code>: 用于记录描述程序正常操作的信息消息。  </li><li><code>SUCCESS (25)</code>: 类似于INFO，用于指示操作成功的情况。  </li><li><code>WARNING (30)</code>: 警告类型，用于指示可能需要进一步调查的不寻常事件。  </li><li><code>ERROR (40)</code>: 错误类型，用于记录影响特定操作的错误条件。  </li><li><code>CRITICAL (50)</code>: 严重类型，用于记录阻止核心功能正常工作的错误条件。  </li></ul><blockquote><p>在终端上，可以看到不同类型的日志，已经有不同的颜色加以区分，默认的配置已经很方便的让我们识别和使用了。  </p></blockquote><blockquote><p>输出不包括TRACE级别的日志信息。这是因为Loguru默认使用DEBUG作为其最低日志级别，导致任何严重性低于DEBUG的日志信息都会被忽略。  如果您想更改默认级别，可以使用下面所示的add()方法的级别参数：</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 修改logger的最低日志级别，大于等于INFO才记录日志</span>logger<span class="token punctuation">.</span>add<span class="token punctuation">(</span>level<span class="token operator">=</span><span class="token string">"INFO"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="三、处理日志的方法add"><a href="#三、处理日志的方法add" class="headerlink" title="三、处理日志的方法add():"></a>三、处理日志的方法add():</h3><p>当add函数配置为一个文件时，add方法提供了更多选项来自定义日志文件的处理方式：</p><ul><li>rotate：指定关闭当前日志文件并创建新文件的条件。此条件可以是 int、datetime 或 str，建议使用 str，因为它更易于阅读。 <ul><li>如果是整数值，它对应于当前文件在创建新文件之前允许保留的最大字节数。</li><li>如果是datetime.timedelta 值时，它指示每次旋转的频率，而 datetime.time 指定每个旋转应在一天中发生的时间。</li><li>如果是str值，这是上述类型的变体。</li></ul></li><li>retention：指定在从文件系统中删除每个日志文件之前如何保留日志。 </li><li>compression：如果设置此选项，日志文件将转换为指定的压缩格式。 </li><li>delay：如果设置为 True，则新日志文件的创建将延迟到推送第一条日志消息。 </li><li>mode， buffering， encoding： 这些参数将被传递给 Python 的 open（） 函数，该函数决定了 Python 将如何打开日志文件。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将自动删除超过一分钟的老文件</span>logger<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"loguru.log"</span><span class="token punctuation">,</span> rotation<span class="token operator">=</span><span class="token string">"5 seconds"</span><span class="token punctuation">,</span> retention<span class="token operator">=</span><span class="token string">"1 minute"</span><span class="token punctuation">)</span><span class="token comment"># 将仅保留三个最新文件</span>logger<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"loguru.log"</span><span class="token punctuation">,</span> rotation<span class="token operator">=</span><span class="token string">"5 seconds"</span><span class="token punctuation">,</span> retention<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个完整的配置：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">logger<span class="token punctuation">.</span>add<span class="token punctuation">(</span>    sink<span class="token operator">=</span><span class="token string">"./logs/app.log"</span><span class="token punctuation">,</span>    enqueue<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    rotation<span class="token operator">=</span><span class="token string">"4 weeks"</span><span class="token punctuation">,</span>    retention<span class="token operator">=</span><span class="token string">"4 months"</span><span class="token punctuation">,</span>    encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">,</span>    backtrace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    diagnose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    compression<span class="token operator">=</span><span class="token string">"zip"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>add函数参数的完整解释：</p><ul><li>sink：为记录器生成的每条记录指定目的地。默认情况下，它设置为 sys.stderr。 </li><li>level：指定记录器的最低日志级别。 </li><li>format：用于为日志定义自定义格式。 </li><li>filter：用于确定一条记录是否应该被记录。 </li><li>colorize: 采用布尔值并确定是否应启用终端着色。 </li><li>serialize：如果设置为 True，则日志记录以 JSON 格式呈现。 </li><li>backtrace：确定异常跟踪是否应该延伸到捕获错误的点之外，以便于调试。 诊断：确定变量值是否应显示在异常跟踪中。您应该在生产环境中将其设置为 False 以避免泄露敏感信息。 </li><li>diagnose: 确定变量值是否应在异常跟踪中显示。在生产环境中应将其设置为 False，以避免泄露敏感信息。</li><li>enqueue：启用此选项会将日志记录放入队列中，以避免多个进程记录到同一目的地时发生冲突。 </li><li>catch：如果在记录到指定的接收器时发生意外错误，您可以通过将此选项设置为 True 来捕获该错误。错误将打印到标准错误。</li></ul><hr><h3 id="四、异常捕获"><a href="#四、异常捕获" class="headerlink" title="四、异常捕获"></a>四、异常捕获</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> loguru <span class="token keyword">import</span> logger<span class="token decorator annotation punctuation">@logger<span class="token punctuation">.</span>catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">e_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    logger<span class="token punctuation">.</span>add<span class="token punctuation">(</span>sink<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">,</span> <span class="token string">'日志文件.log'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>               <span class="token builtin">format</span><span class="token operator">=</span><span class="token string">r"{time:YYYY-MM-DD HH:mm:ss} | "</span>                      <span class="token string">"{level: &lt;5} \t| "</span>                      <span class="token string">"{module}.{function}:{line} - {message}"</span><span class="token punctuation">,</span>               encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">,</span> level<span class="token operator">=</span><span class="token string">"INFO"</span><span class="token punctuation">,</span> enqueue<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    e_test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日志输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2024</span>-02-66 <span class="token number">14</span>:47:12 <span class="token operator">|</span> ERROR <span class="token operator">|</span> logger_test.<span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>:31 - An error has been caught <span class="token keyword">in</span> <span class="token keyword">function</span> <span class="token string">'&lt;module&gt;'</span>, process <span class="token string">'MainProcess'</span> <span class="token punctuation">(</span><span class="token number">4988</span><span class="token punctuation">)</span>, thread <span class="token string">'MainThread'</span> <span class="token punctuation">(</span><span class="token number">11372</span><span class="token punctuation">)</span>:Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:<span class="token operator">&gt;</span> File <span class="token string">"E:\Coding\Pycharm\logger_test.py"</span>, line <span class="token number">31</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>    e_test<span class="token punctuation">(</span><span class="token punctuation">)</span>    └ <span class="token operator">&lt;</span>function e_test at 0x0000021B6EA144C<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>  File <span class="token string">"E:\Coding\Pycharm\logger_test.py"</span>, line <span class="token number">22</span>, <span class="token keyword">in</span> e_test    a <span class="token operator">=</span> <span class="token number">1</span> / <span class="token number">0</span>ZeroDivisionError: division by zero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://cloud.tencent.com/developer/article/2295354">Python日志库Loguru教程（最人性化的Python日志模块）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="loguru" scheme="https://www.chanpoe.top/tags/loguru/"/>
    
  </entry>
  
  <entry>
    <title>Python 面向对象编程</title>
    <link href="https://www.chanpoe.top/posts/a1b78483.html"/>
    <id>https://www.chanpoe.top/posts/a1b78483.html</id>
    <published>2023-05-31T02:33:35.000Z</published>
    <updated>2024-11-19T12:49:44.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><ul><li><p>面向对象(Object-oriented programming) 是一种符合人类思维习惯的编程思想。现实生活中存在着各种形态不同的事物，这些事物之间存在着各种各样的联系。在程序中使用对象来映射现实中的事物，使用对象的关系来描述事物之间的联系，这种思想就是面向对象。</p></li><li><p>面向过程，是分析解决问题的需要的步骤，然后用函数把这些步骤一一实现，使用的时候一个一个依次调用就可以了。</p></li><li><p>面向对象，则是把解决的问题按照一定的规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。当然，一个应用程序会包含多个对象，通过多个对象的相互配合来实现应用程序的功能，这样当应用程序功能发生变化时，只需要修改个别的对象就可以了，从而使代码更容易得到维护。</p><blockquote><p> 换种方法说：面向对象就是：<strong>把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象</strong>。 对同类对象抽象出其共性，形成类。 类中的大多数数据，只能用本类的方法进行处理。 类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。</p></blockquote><hr></li></ul><h3 id="一、面向对象技术："><a href="#一、面向对象技术：" class="headerlink" title="一、面向对象技术："></a>一、面向对象技术：</h3><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量, 用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><hr><h3 id="二、创建类："><a href="#二、创建类：" class="headerlink" title="二、创建类："></a>二、创建类：</h3><p>使用class语句创建：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ClassName</span><span class="token punctuation">:</span>    <span class="token string">'类的帮助信息'</span>    class_suite  <span class="token comment"># 类体</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>其中类的帮助信息可以通过<code>ClassName.__doc__</code>查看</p><p><code>class_suite</code>由类成员、方法、数据属性构成。</p></blockquote><p>下面是一个简单的Python类的例子：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">:</span>   <span class="token string">'所有员工的基类'</span>   empCount <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">:</span>      self<span class="token punctuation">.</span>name <span class="token operator">=</span> name      self<span class="token punctuation">.</span>salary <span class="token operator">=</span> salary      Employee<span class="token punctuation">.</span>empCount <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">def</span> <span class="token function">displayCount</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Total Employee %d"</span> <span class="token operator">%</span> Employee<span class="token punctuation">.</span>empCount<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">displayEmployee</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Name : "</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>  <span class="token string">", Salary: "</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>salary<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。</li><li>第一种方法<code>__init__()</code>方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法</li><li>self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</li></ul></blockquote><p>注：self 不是 python 关键字，我们把他换成 chanpoe也是可以正常执行的</p><hr><h3 id="三、创建实例对象："><a href="#三、创建实例对象：" class="headerlink" title="三、创建实例对象："></a>三、创建实例对象：</h3><p>在其他语言中，实例化类一般用关键字new，但是python没有这个关键字，类的实例化类似函数调用的方式。下面是类的实例化的例子：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">emp1 <span class="token operator">=</span> Employee<span class="token punctuation">(</span><span class="token string">'Chanpoe'</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span>emp2 <span class="token operator">=</span> Employee<span class="token punctuation">(</span><span class="token string">'Chanpoe2'</span><span class="token punctuation">,</span> <span class="token number">15000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>上述示例使用类的名称 Employee 来实例化，并通过 <code>__init__</code> 方法接收参数</p></blockquote><p>访问对象的属性：</p><p>可以使用<code>.</code>来访问对象的属性，例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">emp1<span class="token punctuation">.</span>displayEmployee<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Name <span class="token builtin class-name">:</span>  Chanpoe , Salary:  <span class="token number">20000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以添加、删除、修改类的属性：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">emp1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>  <span class="token comment"># 添加一个age属性</span>emp1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">19</span>  <span class="token comment"># 修改age属性</span><span class="token keyword">del</span> emp1<span class="token punctuation">.</span>age  <span class="token comment"># 删除age属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以用如下函数对类的属性增删改查：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">hasattr</span><span class="token punctuation">(</span>emp1<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span>    <span class="token comment"># 如果存在 'age' 属性返回 True。</span><span class="token builtin">getattr</span><span class="token punctuation">(</span>emp1<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span>    <span class="token comment"># 返回 'age' 属性的值</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>emp1<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span> <span class="token comment"># 添加属性 'age' 值为 22</span><span class="token builtin">delattr</span><span class="token punctuation">(</span>emp1<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span>    <span class="token comment"># 删除属性 'age'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="四、Python内置类属性"><a href="#四、Python内置类属性" class="headerlink" title="四、Python内置类属性"></a>四、Python内置类属性</h3><ul><li><code>__dict__ </code> : 类的属性（包含一个字典，由类的数据属性组成）</li><li><code>__doc__</code> :类的文档字符串</li><li><code>__name__</code>: 类名</li><li><code>__module__</code>: 类定义所在的模块（类的全名是’<code>__main__.className</code>‘，如果类位于一个导入模块<code>mymod</code>中，那么<code>className.__module__ </code>等于 <code>mymod</code>）</li><li><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li></ul><hr><h3 id="五、python对象销毁-垃圾回收"><a href="#五、python对象销毁-垃圾回收" class="headerlink" title="五、python对象销毁(垃圾回收)"></a>五、python对象销毁(垃圾回收)</h3><p>未完待续</p><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://blog.csdn.net/HuangHe201691/article/details/52932810">面向对象（CSDN）</a></p><p><a href="https://www.runoob.com/python/python-object.html">Python 面向对象（菜鸟教程）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="面向对象" scheme="https://www.chanpoe.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python 装饰器</title>
    <link href="https://www.chanpoe.top/posts/d89d2c35.html"/>
    <id>https://www.chanpoe.top/posts/d89d2c35.html</id>
    <published>2023-05-28T15:55:21.000Z</published>
    <updated>2024-11-19T12:49:44.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤，有了长裤后宝宝再也不冷了，装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p><h3 id="一、什么是装饰器？"><a href="#一、什么是装饰器？" class="headerlink" title="一、什么是装饰器？"></a>一、什么是装饰器？</h3><blockquote><p>装饰器（decorator）是函数嵌套定义的另一个重要应用。装饰器本质上也是一个函数，只不过这个函数接收其他函数作为参数并对其进行一定的改造之后返回新函数。</p><p>它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p></blockquote><hr><h3 id="二、需要的前置知识："><a href="#二、需要的前置知识：" class="headerlink" title="二、需要的前置知识："></a>二、需要的前置知识：</h3><p>在此之前需要掌握函数<strong>带括号</strong>和<strong>不带括号</strong>的时候分别表示什么：</p><p>现在有一个cal函数定义如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cal</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> x <span class="token operator">+</span> y    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时可以说，我们创建了一个叫做cal的函数对象，然后你可以这样使用它：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，这样使用它：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">calculate <span class="token operator">=</span> calcalculate<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在第一种方式下，我们直接使用了cal这个函数对象；在第二种方式下，我们将一个名叫calculate的变量指向了cal这个函数对象，可以把这个过程看作“实例化”</p><p>也就是说，对象，就像是一个模子，当你需要的时候，就用它倒一个模型出来，每一个模型可以有自己不同的名字。在上面的例子中，calculate是一个模型，而cal函数就是一个模子。</p><p>OK，接下来就可以理解函数<strong>带括号和不带括号</strong>分别代表的意义了：</p><blockquote><p>在上面那个例子中，如果只写一个cal，那么此时的cal仅代表一个函数对象，但是当我们写cal(1, 2)的时候，就相当于告诉编译器 “执行cal这个函数”</p></blockquote><hr><h3 id="三、装饰器："><a href="#三、装饰器：" class="headerlink" title="三、装饰器："></a>三、装饰器：</h3><p>现在假设我们要编写一个函数，计算两个数相加所需要的时间：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> a <span class="token operator">+</span> b    exec_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'add函数，花费的时间是：</span><span class="token interpolation"><span class="token punctuation">{</span>exec_time<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> resadd<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，假如现在又有减法、乘法、除法等各种函数，你都想计算他们的耗时，因此需要同样编写像上面一样长的代码很多次，显然这样会显得很麻烦，而且也不灵活，万一计算时间的代码有所改动（假设需要每个计算的时间都保留两位小数），每个函数都得改……</p><p>此时，我们的装饰器就是最好的解决方案：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">timer</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        exec_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time        <span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> <span class="token string">"函数花费的时间是："</span><span class="token punctuation">,</span> exec_time<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">return</span> wrapper<span class="token decorator annotation punctuation">@timer</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token decorator annotation punctuation">@timer</span><span class="token keyword">def</span> <span class="token function">sub</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> a <span class="token operator">-</span> badd<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>sub<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注：</strong></p><p>在这个装饰器中，返回的 <code>res</code> 是被修饰函数 <code>func</code> 的返回值。也就是说，在使用 <code>timer</code> 装饰器修饰一个函数后，被修饰函数的返回值会被装饰器包装成一个新的函数，并再次返回到调用端。具体代码示例如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@timer</span><span class="token keyword">def</span> <span class="token function">my_func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>  time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token keyword">return</span> x<span class="token comment"># 调用</span>result <span class="token operator">=</span> my_func<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 输出 "my_func 函数花费的时间是： 2.002307176589966"，返回值为 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>wrapper</code> 这个新函数中，我们首先调用了被修饰函数 <code>func</code>，并将其返回值 <code>res</code> 存储下来。接着我们计算出 <code>func</code> 执行的时间，并将其输出到控制台。最后，我们使用 <code>return</code> 语句返回 <code>res</code>，是为了让被装饰函数的返回值能够被正常地传递到调用端，而不会被装饰器函数丢失。</p><p>当装饰器函数返回 <code>wrapper</code> 函数时，我们没有加上括号的原因是，此处返回的是一个函数对象，而不是调用函数得到的返回值。换句话说，我们返回的是一个可调用对象，而不是调用函数。因此，没有必要在返回语句中加上括号。同时，如果在返回时加上了括号，就相当于是在调用返回的 <code>wrapper</code> 函数，这应该不是我们想要的效果。</p></blockquote><hr><h3 id="四-装饰器运行的顺序"><a href="#四-装饰器运行的顺序" class="headerlink" title="四. 装饰器运行的顺序"></a>四. 装饰器运行的顺序</h3><blockquote><p>在函数定义阶段：执行顺序是从最靠近函数的装饰器开始，自内而外的执行<br>在函数执行阶段：执行顺序由外而内，一层层执行</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deco1</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'deco1 start'</span><span class="token punctuation">)</span>    func<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'deco1 end'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> wrapper<span class="token keyword">def</span> <span class="token function">deco2</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'deco2 start'</span><span class="token punctuation">)</span>    func<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'deco2 end'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> wrapper<span class="token decorator annotation punctuation">@deco1</span><span class="token decorator annotation punctuation">@deco2</span><span class="token keyword">def</span> <span class="token function">my_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'original function'</span><span class="token punctuation">)</span>my_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该示例中，<code>my_func</code> 函数被 <code>deco1</code> 和 <code>deco2</code> 装饰器修饰。在函数执行时，实际上等价于以下代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_func <span class="token operator">=</span> deco1<span class="token punctuation">(</span>deco2<span class="token punctuation">(</span>my_func<span class="token punctuation">)</span><span class="token punctuation">)</span>my_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">deco1 startdeco2 startoriginal functiondeco2 enddeco1 end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><del>很难用语言描述这个顺序，意会一下。我感觉是因为定义的时候返回的是函数对象，并没有执行，然后在执行的时候就是最外层最先开始执行。</del></p><hr><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://www.zhihu.com/question/26930016">如何理解Python装饰器（知乎）</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NjgzODM3Ng==&amp;mid=2650534086&amp;idx=2&amp;sn=0a9db486758dd803c45506bd8dafff77&amp;chksm=88a6a741bfd12e57accf3001c306a2790c10b5063aed6d1fb03680b052bca906f203a09cb500&amp;scene=27">一文带你迅速掌握python装饰器（微信公众号）</a></p><p><a href="https://blog.csdn.net/murenyangdaren/article/details/115387165">python装饰器函数执行顺序（CSDN）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="装饰器" scheme="https://www.chanpoe.top/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python 函数注解</title>
    <link href="https://www.chanpoe.top/posts/b39b89bc.html"/>
    <id>https://www.chanpoe.top/posts/b39b89bc.html</id>
    <published>2023-05-27T15:46:37.000Z</published>
    <updated>2024-11-19T12:49:44.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h3><p><code>-&gt;</code>常常出现在python函数定义的函数名后面（在<code>:</code>的前面），为函数添加元数据，描述函数的返回类型，也可以理解为给函数添加注解。在定义函数时使用特殊的语法来注释函数的参数和返回值的类型。这些注解不会影响函数的行为，但可以提供更详细的文档，以及一些类型检查工具可以使用这些注解来进行静态类型检查。</p><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>  <span class="token keyword">return</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"! You are "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" years old."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个例子中，函数<code>greet</code>的第一个参数<code>name</code>有一个注解<code>str</code>，表示这个参数应该是一个字符串类型。第二个参数<code>age</code>有一个注解<code>int</code>，表示这个参数应该是一个整数类型。返回值也有一个注解<code>str</code>，表示该函数将返回一个字符串类型的值。</p><p>Python解释器不会对这些注解添加任何的语义。它们不会被类型检查，运行时跟没有加注解之前的效果也没有任何差距。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python" scheme="https://www.chanpoe.top/categories/Python/"/>
    
    
    <category term="函数注解" scheme="https://www.chanpoe.top/tags/%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
</feed>
